---
date: 2026-02-16 15:16:23
title: MyBatis
permalink: /tech/86f7a8
categories:
  - 代码宇宙
  - 框架与库
---



![img](/imgs/20211015213354.png)

### 1. 简介

#### 1-1. 如何获取

- maven仓库：[**https://mvnrepository.com/artifact/org.mybatis/mybatis**](https://mvnrepository.com/artifact/org.mybatis/mybatis)

  ```xml
  <dependency>    
      <groupId>org.mybatis</groupId>   
      <artifactId>mybatis</artifactId>
      <version>3.4.6</version>
  </dependency>
  ```

- Github：[https://github.com/mybatis/mybatis-3/](https://github.com/mybatis/mybatis-3/)
- 官方文档：[https://mybatis.org/mybatis-3/zh/index.html](https://mybatis.org/mybatis-3/zh/index.html)

#### 1-2. 什么是MyBatis

- MyBatis 是一款优秀的持久层框架
- 它支持自定义 SQL、存储过程以及高级映射

- MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作
- MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。

- MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis
- 2013年11月迁移到Github

#### 1-3. 持久化4

数据持久化

- 持久化就是将程序的数据在持久状态和瞬时状态转化的过程
- 内存：**断电即失**

- 数据库（jdbc）、io文件持久化
- 生活：冷藏

为什么需要持久化

- 有一些数据，不能丢掉
- 内存很贵

#### 1-4. 持久层

Dao层、Service层、Controller层......

- 完成持久化工作的代码块
- 层界限十分明显

#### 1-5. 为什么需要Mybatis

- 帮助程序员将数据存入到数据库中
- 方便

- 传统的JDBC代码太复杂
- 不用MyBayis也可以，这个更容易上手。**技术没有高低之分**

#### 1-5. 优点

- 简单易学，灵活
- sql和代码分离，提高了可维护性

- 提供映射标签，支持对象与数据库的orm字段关系映射
- 提供对象关系映射标签，支持对象关系组建维护

- 提供xml标签，支持编写动态sql

### 2. 第一个MyBatis程序

#### 2-1. 数据库搭建

```sql
CREATE DATABASE mybatis1;
USE mybatis1;
CREATE TABLE USER(
    id INT(20) NOT NULL PRIMARY KEY,
    NAME VARCHAR(30) DEFAULT NULL,
    pwd VARCHAR(30) DEFAULT NULL
)ENGINE=INNODB DEFAULT CHARSET=utf8;# engine为引擎
INSERT INTO USER(id, NAME, pwd) VALUES
(1, '张三', '123'),
(2, '李四', 'root'),
(3, '王五', 'admin')
```

#### 2-2. 新建maven项目

1. 新建一个普通的maven项目
2. 删除src文件夹

3. 在pom.xml中导入依赖

```xml
<!--mysql驱动、mybatis、junit--> 
<!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --> 
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId> 
    <version>8.0.26</version>
</dependency>
<!-- https://mvnrepository.com/artifact/org.mybatis/mybatis -->
<dependency>
    <groupId>org.mybatis</groupId> 
    <artifactId>mybatis</artifactId>
    <version>3.5.6</version>
</dependency>
<!-- https://mvnrepository.com/artifact/junit/junit -->
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.12</version>
</dependency>
```

#### 2-3. 创建一个模块

- 编写mybatis核心配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration 
    PUBLIC"-//mybatis.org//DTD Config 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <environments default="development">
    	<environment id="development">
    		<transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://localhost:3306/mybatis1?useSSL=true&useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai"/>
                <property name="username" value="root"/>
                <property name="password" value="root"/>
    		</dataSource>
    	</environment>
    </environments>
    <mappers>
    	<mapper resource="org/mybatis/example/BlogMapper.xml"/>
    </mappers>
</configuration>
```

- 编写mybatis工具类

```java
// SqlSessionFactory --> SqlSession 
public class MybatisUtils {
    public static SqlSessionFactory sqlSessionFactory;
    static {
        try {
            // 第一步 获取SqlSessionFactory对象
            String resource =** **"mybatis-config.xml;
            InputStream inputStream = Resources.getResourceAsStream(resource);
            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    // 既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。
    // SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。
    // 你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。
    public static SqlSession getSqlSession() {
        return sqlSessionFactory.openSession();
    }
}
```

#### 2-4. 编写代码

2-4-1. 实体类

```java
public class User {
    private int id;
    private String name;
    private String pwd;
}
```

2-4-2. Dao接口（Dao以后借用Mapper代替）

```java
import java.util.List;
public interface UserDao {
    List<User> getUserList();
}
```

2-4-3. 接口实现类

namespace绑定一个对应的Dao/Mapper接口

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
	PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
	"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="con.demo1.dao.UserMapper">
    <select id="getUserList" resultType="com.demo1.pojo.User">
        select * from user
    </select>
</mapper>
```

2-4-4. 测试

```java
public class UserDaoTest1 {
    @Test
    public void run1() {
        SqlSession sqlSession = MybatisUtils.getSqlSession();
        // 方式一：getMapper()----->推荐
        UserDao mapper = sqlSession.getMapper(UserDao.class);
        List<User> list = mapper.getUserList();
        // 方式二：select...()
        list = sqlSession.selectList("getUserList");
        for(User user : list) { 
            System.out.println(user);
        }
        sqlSession.close();
    }
} 
```

**问题：**

1. org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: java.io.IOException: Could not find resource org/mybatis/example/**BlogMapper.xml**

**配置文件没有注册，解决：在mybatis-config.xml中**

```xml
<mappers>
    <mapper resource="com/demo1/dao/UserMapper.xml"/>
</mappers>
```

2. java.lang.ExceptionInInitializerError

​    \### The error may exist in com/demo1/dao/UserMapper.xml

​	这是maven的资源过滤问题：maven由于他的约定大于配置，我们之后可能会遇到我们写的配置文件，无法被导出或生效的问题，如这次，原因是maven项目默认资源文件夹为rescourses，所以在java文件夹里的配置文件会被过滤，解决方案：

```xml
<!--在pom.xml里配置build中的resources，来防止我们资源导出失败的问题-->
    <build>
        <resources>
            <resource>
                <directory>src/main/resources</directory>
                <includes>
                    <include>**/*.properties</include>
                    <include>**/*.xml</include>
                </includes>
<!--                <filtering>true</filtering>-->
            </resource>
            <resource>
                <directory>src/main/java</directory>
                <includes>
                    <include>**/*.properties</include>
                    <include>**/*.xml</include>
                </includes>
<!--                <filtering>true</filtering>-->
            </resource>
        </resources>
    </build>
```



3. java.lang.ExceptionInitializerError

   1 字节的 UTF-8 序列的字节 1 无效

解决：

- 方式一：在mybatis-comfig.xml和mapper.xml文件中不要有中文，连注释都不能有中文
- 方式二：在mybatis-comfig.xml和mapper.xml文件第一行的 `<?xml version="1.0" encoding="UTF-8"?>` 把UTF-8改为UTF8

### 3. CRUD

#### 3-1. namespace

namespace就是对应mapper接口的全类名

#### 3-2. select

- id：就是对应的namespace中的方法名
- resultType：Sql语句执行的返回值

- parameterType：参数类型，如int、String

```xml
// 根据id查询单个用户
<select id="getUserById" parameterType="int" resultType="com.demo1.pojo.User">
    elect * from user where id = #{id}		<!-- #{}里面写什么跟形参有关 -->
</select>
```

#### 3-3. insert

```xml
// insert一个用户
<insert id="addUser" parameterType="com.demo1.pojo.User">
    insert into user(id, name, pwd) values(#{id}, #{name}, #{pwd})*;
</insert>
```

#### 3-4 updata

```xml
// 修改一个用户信息
<update id="updataUser" parameterType="com.demo1.pojo.User">
	update user set name=#{name}, pwd=#{pwd} where id = #{id};
</update>
```

#### 3-5. delete

```xml
// 删除一个用户 
<delete id="delUser" parameterType="int">
    delete from user where id=#{id};
</delete>
```

**注意：增删改需要提交事务：sqlSession.commit();**

3-6. 万能Map（野路子）

假如，我们的数据库中的表或者实体类，字段或参数过多，但我们只获取或改动少量字段，这时我们应该使用Map

```java
// 修改密码
int updataPwd(Map<String, Object> map);
```

```xml
<update id="updataPwd" parameterType="map" >
    update user set pwd=#{userpwd} where id = #{userid};
</update>
```

```java
public void mapRun() {
        SqlSession sqlSession = MybatisUtils.getSqlSession();
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        Map<String, Object> map = new HashMap<String, Object>();
        map.put("userid", 5);
        map.put("userpwd", "123456");
        mapper.updataPwd(map);
        sqlSession.commit();
        sqlSession.close();
    }
```

#### 3-7 思考题

**模糊查询怎么写：**

1. 在Java代码中传递通配符

```sql
select * from user where name like #{val};
```

```java
List<User> list = mapper.getUserLike("李_");
```

2. 在sql语句中拼接通配符

```sql
select * from user where name like #{val}"_";
```

```java
List<User> list = mapper.getUserLike("李");
```

#### 3-8. 其他

- Map为方法形参，在sql中直接取出key即可：【**parameterType="map"**】
- 对象为方法形参，在sql中取对象的属性即可：【**parameterType="com.demo1.pojo.User"**】

- 基本数据类型为方法形参，在sql中直接用即可
- 形参若为多个，用Map或者**注解方式**传递参数

### 4. 配置解析

#### 4-1. 核心配置文件

- mybatis-config.xml
- MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息

- 在xml中，`<configuration>`内所有的标签都规定了顺序，其规定顺序如下：
- properties,settings,typeAliases,typeHandlers,objectFactory,objectWrapperFactory,reflectorFactory,plugins,environments,databaseIdProvider,mappers

![20211015231959.png](/imgs/20211015231959.png)

#### 4-3. 环境配置（environment）

- MyBatis 可以配置成适应多种环境
- **尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境，即每个数据库对应一个 SqlSessionFactory 实例**

- 学会配置多套运行环境
- MyBatis默认事务管理器是JDBC，默认连接池类型是POOLED

```xml
<environments default="development">
    <environment id="development">
        <transactionManager type="JDBC"/>
        <dataSource type="POOLED">
            <property name="driver" value="${driver}"/>
            <property name="url" value="${url}"/>
            <property name="username" value="${username}"/>
            <property name="password" value="${password}"/>
        </dataSource>
    </environment>
</environments>
```

#### 4-4. 属性（properties）

- 我们可以通过properties属性来实现引用配置文件
- 这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置

4-4-1. db.properties

- 在.properties文件中，平级分割符为 '&' 

```properties
driver=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/mybatis1?useSSL=true&useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai
username=root
password=root
```

4-4-2. 在核心配置文件（mybatis-config.xml）中引入db.properties

```properties
<properties resource="db.properties"/>
```

#### 4-4. 类型别名（typeAliases）

- 类型别名可为 Java 类型设置一个缩写名字。 
- 它仅用于 XML 配置，意在降低冗余的全限定类名书写

4-4-1. 类别名

```xml
<typeAliases>
    <typeAlias type="com.demo1.pojo.User" alias="User"/>
</typeAliases>
```

4-4-2. 包别名

- 为包配别名后，在此包中的JavaBean，默认Bean的首字母小写类名作为别名，注解会覆盖默认别名，Bean原类名则为真实名字，别名优先级更大

```xml
<typeAliases>
    <package name="com.demo1.pojo"/>
</typeAliases>
```

```java
@Alias("user")
```

#### 4-5. 设置（setting）

- 这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为

4-5-1. 需要掌握

| **设置名**               | **描述**                                            | **有效值**                                                                                 | **默认值** |
| ------------------------ | --------------------------------------------------- | ------------------------------------------------------------------------------------------ | ---------- |
| cacheEnabled             | 全局缓存是否开启                                    | true \| false                                                                              | true       |
| lazyLoadingEnabled       | 懒加载                                              | true \| false                                                                              | false      |
| useGeneratedKeys         | JDBC自动生成主键                                    | true \| false                                                                              | false      |
| mapUnderscoreToCamelCase | 是否开启自动驼峰命名规则映射                        | true \| false                                                                              | false      |
| logImpl                  | 指定 MyBatis 所用日志的具体实现，未指定时将自动查找 | SLF4J \| LOG4J \| LOG4J2 \| JDK_LOGGING \| COMMONS_LOGGING \| STDOUT_LOGGING \| NO_LOGGING | 未设置     |

####  4-5. 映射器（mappers）

MapperRegistry：注册绑定mapper文件

4-5-1. 文件路径引用

```xml
<mappers>
    <mapper resource="com/demo1/mapper/UserMapper.xml"/>
</mappers>
```

4-5-2. 映射器接口引用

- 有限制，不推荐
  - 接口和它的mapper配置文件必须同名
  - 接口和它的mapper配置文件必须在同一个包下


```xml
<mappers>
    <mapper class="com.demo1.mapper.UserMapper"/>
</mappers>
```

4-5-3. 扫描包引用

- 限制同第2条，不推荐

```xml
<mappers>
    <package name="com.demo1.mapper"/>
</mappers>
```

#### 4-6. 生命周期和作用域

- 生命周期和作用域是至关重要的，因为错误的使用会导致非常严重的**并发问题**
- SqlSessionFactoryBuilder

  - 一旦创建了 SqlSessionFactory，就不再需要它了

- SqlSessionFactory

  - 可以想像为数据库连接池
  - 一旦被创建就应该在应用的运行期间一直存在，**没有任何理由丢弃它或重新创建另一个实例**

  - 因此 SqlSessionFactory 的最佳作用域是应用作用域
  - 最简单的就是使用**单例模式**或者静态单例模式

- SqlSession

  - 可以想像为连接到连接池的一个请求
  - SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域

  - 用完之后立即关掉，否则资源被占用

- 每一个mapper都代表一个具体的业务

#### 5. 解决JavaBean属性名与数据表字段名不一致的问题

- JavaBean类

```java
package com.demo1.pojo;

public class User {
    private int id;
    private String name;
    private String password;
}
```

- 对应数据表

![img](/imgs/20211015232848.png)

- 不报错，但结果查出来却为null

![img](/imgs/20211015232921.png)

- 原因/实质

  - mapper的sql语句**select * from user;**
  - 其真实语句为**select id, name, pwd from user;**

- 解决方案

  - 起别名（不推荐）

```xml
<select id="getUserList" resultType="User">
    select id, name, pwd as password from user;
</select>
```

- - resultMap（结果集映射）

```xml
<resultMap id="UserMap" type="User">
    <result column="pwd" property="password"/>
</resultMap>
<select id="getUserList" resultMap="UserMap">
 select * from user;
</select>
```

- - - resultMap 元素是 MyBatis 中最重要最强大的元素
    - resultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了

### 6.日志

#### 6-1. 日志工厂

如果一个数据库操作出现了异常，我们需要排错，所以日志就是最好的助手。

曾经的手段：System.out.println()、 debug

现在：日志工厂

| **设置名** | **描述**                                            | **有效值**                                                                                 | **默认值** |
| ---------- | --------------------------------------------------- | ------------------------------------------------------------------------------------------ | ---------- |
| logImpl    | 指定 MyBatis 所用日志的具体实现，未指定时将自动查找 | SLF4J \| LOG4J \| LOG4J2 \| JDK_LOGGING \| COMMONS_LOGGING \| STDOUT_LOGGING \| NO_LOGGING | 未设置     |

- SLF4J
- **LOG4J	【重点】**

- **LOG4J2  【重点】**
- JDK_LOGGING

- COMMONS_LOGGING
- **STDOUT_LOGGING：标准日志	【重点】其他只做了解**

- NO_LOGGING

#### 6-2. STDOUT_LOGGING

```xml
<settings>
    <setting name="logImpl" value="STDOUT_LOGGING"/>
</settings>
```

![img](/imgs/20211015233426.png)

#### 6-3. LOG4J

6-3-1. 什么是Log4j

- Log4j是Apache的一个开源项目，通过使用Log4j可以控制日志信息输送的目的地是控制台、文件、GUI组件
- 我们也可以控制每一条日志的输出格式

- 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程
- 最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码

6-3-2. 导入依赖

```xml
<!-- https://mvnrepository.com/artifact/log4j/log4j -->
<dependency>
    <groupId>log4j</groupId>
    <artifactId>log4j</artifactId>
    <version>1.2.17</version>
</dependency>
```

6-3-3. log4j.properties

```properties
#将等级为DEBUG级别的日志信息输出到console和file这两个目的地。console和file的定义在下面的代码
log4j.rootLogger=DEBUG,console,file
#控制台输出的相关设置
log4j.appender.console = org.apache.log4j.ConsoleAppender
log4j.appender.console.Target = System.out
log4j.appender.console.Threshold=DEBUG
log4j.appender.console.layout = org.apache.log4j.PatternLayout
log4j.appender.console.layout.ConversionPattern=[%c]-%m%n
#文件输出的相关设置
log4j.appender.file = org.apache.log4j.RollingFileAppender
log4j.appender.file.File=./log/mylog.1og
log4j.appender.fi1e.MaxFilesize=10mb
log4j.appender.file.Threshold=DEBUG
log4j.appender.file.layout=org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n
#日志输出级别
log4j.logger.org.mybatis=DEBUG
log4j.logger.java.sq1=DEBUG
log4j.logger.java.sq1.statement=DEBUG
1og4j.logger.java.sq1.ResultSet=DEBUG
log4j.logger.java.sq1.PreparedStatement=DEBUG
```

`log4j2.xml`：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!--日志级别以及优先级排序: OFF > FATAL > ERROR > WARN > INFO > DEBUG > TRACE > ALL -->
<!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出-->
<!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数-->
<configuration status="WARN" monitorInterval="30">
    <!--先定义所有的appender-->
    <appenders>
        <!--这个输出控制台的配置-->
        <console name="Console" target="SYSTEM_OUT">
            <!--输出日志的格式-->
            <PatternLayout pattern="[%d{HH:mm:ss:SSS}] [%p] - %l - %m%n"/>
        </console>
        <!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，这个也挺有用的，适合临时测试用-->
        <File name="log" fileName="log/test.log" append="false">
            <PatternLayout pattern="%d{HH:mm:ss.SSS} %-5level %class{36} %L %M - %msg%xEx%n"/>
        </File>
        <!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档-->
        <RollingFile name="RollingFileInfo" fileName="${sys:user.home}/logs/info.log"
                     filePattern="${sys:user.home}/logs/$${date:yyyy-MM}/info-%d{yyyy-MM-dd}-%i.log">
            <!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）-->
            <ThresholdFilter level="info" onMatch="ACCEPT" onMismatch="DENY"/>
            <PatternLayout pattern="[%d{HH:mm:ss:SSS}] [%p] - %l - %m%n"/>
            <Policies>
                <TimeBasedTriggeringPolicy/>
                <SizeBasedTriggeringPolicy size="100 MB"/>
            </Policies>
        </RollingFile>
        <RollingFile name="RollingFileWarn" fileName="${sys:user.home}/logs/warn.log"
                     filePattern="${sys:user.home}/logs/$${date:yyyy-MM}/warn-%d{yyyy-MM-dd}-%i.log">
            <ThresholdFilter level="warn" onMatch="ACCEPT" onMismatch="DENY"/>
            <PatternLayout pattern="[%d{HH:mm:ss:SSS}] [%p] - %l - %m%n"/>
            <Policies>
                <TimeBasedTriggeringPolicy/>
                <SizeBasedTriggeringPolicy size="100 MB"/>
            </Policies>
            <!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件，这里设置了20 -->
            <DefaultRolloverStrategy max="20"/>
        </RollingFile>
        <RollingFile name="RollingFileError" fileName="${sys:user.home}/logs/error.log"
                     filePattern="${sys:user.home}/logs/$${date:yyyy-MM}/error-%d{yyyy-MM-dd}-%i.log">
            <ThresholdFilter level="error" onMatch="ACCEPT" onMismatch="DENY"/>
            <PatternLayout pattern="[%d{HH:mm:ss:SSS}] [%p] - %l - %m%n"/>
            <Policies>
                <TimeBasedTriggeringPolicy/>
                <SizeBasedTriggeringPolicy size="100 MB"/>
            </Policies>
        </RollingFile>
    </appenders>
    <!--然后定义logger，只有定义了logger并引入的appender，appender才会生效-->
    <loggers>
        <!--过滤掉spring和mybatis的一些无用的DEBUG信息-->
        <logger name="org.springframework" level="INFO"></logger>
        <logger name="org.mybatis" level="INFO"></logger>
        <root level="all">
            <appender-ref ref="Console"/>
            <appender-ref ref="RollingFileInfo"/>
            <appender-ref ref="RollingFileWarn"/>
            <appender-ref ref="RollingFileError"/>
        </root>
    </loggers>
</configuration>
```

6-3-4. 配置log4j为日志的实现

```xml
<settings>
        <setting name="logImpl" value="LOG4J"/>
</settings>
```

6-3-5. log4j的显示

![img](/imgs/20211015233648.png)

6-3-6. 简单应用

```java
@Test
public void log4jTest() {
    Logger logger = Logger.getLogger(MyTest.class);
    logger.info("[info]:MyTest.log4jTest()......");
    logger.debug("[debug]:MyTest.log4jTest()......");
    logger.error("[error]:MyTest.log4jTest()......");
}
```

![img](/imgs/20211015233729.png)

### 7. 分页

- 为什么要分页：减少数据的处理量

#### 7-1. 使用limit分页

7-1-1. 语法

```sql
select * from user limit 0, 2;     # star, step
```

![img](/imgs/20211015233854.png)

7-1-2. 接口UserMapper.java

```xml
// 分页查询
List<User> getUserByLimit(Map<String, Object> map);
```

7-1-3. UserMapper.xml

```xml
<!--    分页实现-->
<resultMap id="userlimit" type="User">
    <result column="pwd" property="password"/>
</resultMap>
<select id="getUserByLimit" parameterType="map" resultMap="userlimit">
    select * from user limit #{star}, #{step}; 
</select>
```

7-1-4. 测试

```java
public void limitTest() {
    SqlSession sqlSession = MybatisUtils.getSqlSession();
    UserMapper mapper = sqlSession.getMapper(UserMapper.class);
    Map<String, Object> map = new HashMap<String, Object>();
    map.put("star", 4);
    map.put("step", 2);
    List<User> l = mapper.getUserByLimit(map);
    for (User user : l) {
        System.out.println(user);
    }
    sqlSession.close();
}
```

#### 7-2. RowBounds分页【了解】

#### 7-3. 分页插件【了解】

网页：[https://pagehelper.github.io/](https://pagehelper.github.io/)

![img](/imgs/20211015234019.png)

### 8. 使用注解开发

#### 8-1. 面向接口编程

- 大家之前都学过面向对象编程，也学习过接口，但在真正的开发中，很多时候我们会选择面向接口编程
- 根本原因︰**解耦**，可拓展，提高复用，分层开发中，上层不用管具体的实现，大家都遵守共同的标准，使得开发变得容易，规范性更好

- 在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的,对系统设计人员来讲就不那么重要了;
- 而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互

- 在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。

**关于接口的理解**

- 接口从更深层次的理解，应是定义(规范，约束）与实现（名实分离的原则）的分离。
- 接口的本身反映了系统设计人员对系统的抽象理解。

- 接口应有两类:

- - 第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class);
  - 第二类是对一个个体某一方面的抽象，即形成一个抽象面(interface) ;

- 一个体有可能有多个抽象面。抽象体与抽象面是有区别的

**三个面向区别**

- 面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性及方法．
- 面向过程是指，我们考虑问题时，以一个具体的流程（事务过程)为单位，考虑它的实现．

- 接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题.更多的体现就是对系统整体的架构

#### 8-2. 一个小例子

- **本质：反射机制实现**
- **底层：动态代理**

```java
public interface UserMapper {
    // 查询全部
    @Select("select * from user")
    List<User> getUserList();
}
```

```xml
<mappers>
    <mapper class="com.demo1.mapper.UserMapper"/>
</mappers>
```

```java
@Test
public void selectAll() {
    SqlSession sqlSession = MybatisUtils.getSqlSession();
    UserMapper mapper = sqlSession.getMapper(UserMapper.class);
    List<User> userList = mapper.getUserList();
    for (User user : userList) {
        System.out.println(user);
    }
    sqlSession.close();
}
```

#### 8-3. MyBatis详细执行流程

1. Resources获取加载全局配置文件
2. 实例化SqlSessionFactoryBuilder构造器

3. 用XMLConfigBuilder解析配置文件流

4. 将所有配置信息保存到Configuration对象里

5. 实例化SqlSessionFactory对象

6. transaction事务管理

7. 创建executor执行器（执行sql语句的）

8. 创建sqlSession

9. 实现CRUD

10. 提交事务

11. 关闭资源

#### 8-4. CRUD

我们可以在工具类创建的时候实现自动提交事务

```java
public static SqlSession getSqlSession() {
    return sqlSessionFactory.openSession(true);
}
```

```java
public interface UserMapper {
    // 查询全部
    @Select("select * from user")
    List<User> getUserList();
    // 根据id查询单个用户
    @Select("select * from user where id = #{id}")      // 当形参有多个时，在所有参数前加上@Param("")注解
    User getUserById(@Param("id") int id);
    // insert一个用户
    @Insert("insert into user (id, name, pwd) values (#{id}, #{name}, #{pwd})")
    int addUser(User user);

    // 修改一个用户信息
    @Update("update user set name = #{name}, pwd = #{pwd} where id = #{id}")
    int updataUser(User user);
    // 删除一个用户
    @Delete("delete from user where id = #{id}")
    int delUser(int id);
}
```

```java
public class MyTest {
    @Test
    public void selectAll() {
        SqlSession sqlSession = MybatisUtils.getSqlSession();
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        List<User> userList = mapper.getUserList();
        for (User user : userList) {
            System.out.println(user);
        }
        sqlSession.close();
    }
    @Test
    public void selectOne() {
        SqlSession sqlSession = MybatisUtils.getSqlSession();
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);

        User userById = mapper.getUserById(2);
        System.out.println(userById);

        sqlSession.close();
    }
    @Test
    public void insertOne() {
        SqlSession sqlSession = MybatisUtils.getSqlSession();
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);

        User user = new User(7, "小小", "112233");
        int i = mapper.addUser(user);
        if (i == 1) {
            System.out.println("addUser成功");
        }

        sqlSession.close();
    }
    @Test
    public void updata() {
        SqlSession sqlSession = MybatisUtils.getSqlSession();
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);

        User user = new User(4, "悠米", "admin");
        int i = mapper.updataUser(user);
        if (i == 1) {
            System.out.println("修改成功");
        }

        sqlSession.close();
    }
    @Test
    public void delOne() {
        SqlSession sqlSession = MybatisUtils.getSqlSession();
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);

        int i = mapper.delUser(7);
        if (i == 1) {
            System.out.println("del成功");
        }

        sqlSession.close();
    }
}
```

**关于@Param("name")注解：**

- **基本类型或String类型需要加上**，引用类型不用加
- 如果只有一个形参的话，可以不加，但是建议都加上

- 我们在sql中引用的就是@Param()中的value值

### 9. Lombok

#### 9-1. 使用

1. 安装lombok插件
2. 导入依赖、

```xml
<!-- https://mvnrepository.com/artifact/org.projectlombok/lombok -->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.20</version>
    <scope>provided</scope>
</dependency>
```

3. 用法

```java
@Getter and @Setter
@FieldNameConstants
@ToString
@EqualsAndHashCode
@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor
@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger, @CustomLog
@Data
@Builder
@SuperBuilder
@Singular
@Delegate
@Value
@Accessors
@Wither
@With
@SneakyThrows
@val
@var
experimental @var
@UtilityClass
```

* **@Data：@NoargsContrutor、@Getter、@Setter、@EqualsAndHashCode、@ToString**

### 10. 多对一的处理

#### 10-1. 搭建测试环境

1. 建数据表

```sql
CREATE TABLE teacher(
id INT(10) NOT NULL PRIMARY KEY,
name VARCHAR(30) DEFAULT NULL
)ENGINE=INNODB DEFAULT CHARSET=utf8;

INSERT INTO teacher (id, name) VALUES (1, '秦老师' );

CREATE TABLE student(
id INT(10) NOT NULL PRIMARY KEY,
name VARCHAR(30) DEFAULT NULL,
tid INT(10)DEFAULT NULL,
KEY fktid (tid) ,
CONSTRAINT fktid FOREIGN KEY (tid) REFERENCES teacher(id)
)ENGINE=INNODB DEFAULT CHARSET=utf8;

INSERT INTO student(id, name, tid) VALUES (1, '小明', 1);
INSERT INTO student(id, name, tid) VALUES (2, '小红', 1);
INSERT INTO student(id, name, tid) VALUES (3, '小张', 1);
INSERT INTO student(id, name, tid) VALUES (4, '小李', 1);
INSERT INTO student(id, name, tid) VALUES (5, '小王', 1);
```

2. 导入依赖

```xml
<!--mysql驱动、mybatis、junit、lombok-->
<!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.26</version>
</dependency>

<!-- https://mvnrepository.com/artifact/org.mybatis/mybatis -->
<dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis</artifactId>
    <version>3.5.6</version>
</dependency>

<!-- https://mvnrepository.com/artifact/junit/junit -->
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.12</version>
</dependency>
<!-- https://mvnrepository.com/artifact/org.projectlombok/lombok -->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.20</version>
    <scope>provided</scope>
</dependency>
```

3. 新建实体类

```java
@Data
public class Teacher {
    private int id;
    private String name;
}
```

```java
@Data
public class Student {
    private int id;
    private String name;
    // 学生需要关联的老师id
    private Teacher teacher;
}
```

4. MyBatis配置文件

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <properties resource="db.properties"/>
    <settings>
        <setting name="logImpl" value="STDOUT_LOGGING"/>
    </settings>
    <typeAliases>
        <package name="com.demo1.pojo"/>
    </typeAliases>
    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="${driver}"/>
                <property name="url" value="${url}"/>
                <property name="username" value="${username}"/>
                <property name="password" value="${password}"/>
            </dataSource>
        </environment>
    </environments>
    <mappers>
        <mapper class="com.demo1.mapper.TeacherMapper"/>
        <mapper class="com.demo1.mapper.StudentMapper"/>
    </mappers>
</configuration>
```

5. 工具类

```java
public class MybatisUtils {
    public static SqlSessionFactory sqlSessionFactory;
    static {
        try {
            String reources = "mybatis-config.xml";
            InputStream inputStream = Resources.getResourceAsStream(reources);
            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static SqlSession getSqlSession() {
        return sqlSessionFactory.openSession(true);
    }
}
```

6. mapper接口

```java
public interface TeacherMapper {

    @Select("select * from teacher where id = #{id}")
    Teacher getTeacherById(@Param("id")int id);
}
```

```java
public interface StudentMapper {
}
```

7. mapper配置文件

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.demo1.mapper.TeacherMapper">

</mapper>
```

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.demo1.mapper.StudentMapper">

</mapper>
```

8. 测试

```java
public class MyTest {
    @Test
    public void selectAll() {
        SqlSession sqlSession = MybatisUtils.getSqlSession();
        TeacherMapper mapper = sqlSession.getMapper(TeacherMapper.class);
        Teacher teacher = mapper.getTeacherById(1);
        System.out.println(teacher);
        sqlSession.close();
    }
}
```

9. 目录结构截图

![img](/imgs/20211015234957.png)

#### 10-2 实例： 查询所有学生，及对应老师

方式一、 分两个查询思路：select * from student;、select * from teacher where id = #{id};

```java
public interface StudentMapper {
    // 查询所有学生信息，以及对应老师的信息
    /**
     * select s.id, s.name, t.id, t.name from student s, teacher t
     * where s.tid = t.id
     */
    public List<Student> getStudent();
    public Teacher getTeacherByTid(int tid);
}
```

```xml
<mapper namespace="com.demo1.mapper.StudentMapper">
<!--
    select s.id, s.name, t.id, t.name from student s, teacher t where s.tid = t.id
    1. 查询所有的学生信息
    2. 根据查询出来学生中的tid，查询对应的老师
    -->
    <resultMap id="StudentTeacher" type="student">
        <!-- 复杂属性映射：association映射对象，collection映射集合 -->
        <association property="teacher" column="tid" javaType="teacher" select="getTeacherByTid"/>
    </resultMap>
    <select id="getStudent" resultMap="StudentTeacher">
         select * from student;
    </select>
    <select id="getTeacherByTid" resultType="teacher">
        select * from teacher where id = #{id};
    </select>
</mapper>
```

```java
@Test
    public void selectStuALl() {
        SqlSession sqlSession = MybatisUtils.getSqlSession();
        StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);
        List<Student> studentList = mapper.getStudent();
        for (Student student : studentList) {
            System.out.println(student);
        }
        sqlSession.close();
    }
}
```

方式二、 嵌套处理：

```java
select s.id sid, s.name sname, t.id tid, t.name tname 
from student s, teacher t 
where s.tid = tid;
```

```java
public interface StudentMapper {
    // 查询所有学生信息，以及对应老师的信息
    /**
     * select s.id sid, s.name sname, t.id tid, t.name tname from student s, teacher t
     * where s.tid = tid;
     */
    public List<Student> getStudent2();
}
```

```xml
<mapper namespace="com.demo1.mapper.StudentMapper">
<!--
    select s.id sid, s.name sname, t.id tid, t.name tname from student s, teacher t
    where s.tid = tid;
    -->
    <resultMap id="StudentTeacher2" type="student">
        <result property="id" column="sid"/>
        <result property="name" column="sname"/>
        <association property="teacher" javaType="teacher">
            <result property="id" column="tid"/>
            <result property="name" column="tname"/>
        </association>
    </resultMap>
    <select id="getStudent2" resultMap="StudentTeacher2">
        select s.id sid, s.name sname, t.id tid, t.name tname from student s, teacher t where s.tid = tid
    </select>
</mapper>
```

### 11. 一对多的处理

#### 11-1. 搭建测试环境

1. 建数据表

   同上

2. 导入依赖

   同上

3. 新建实体类

```java
@Data
public class Student {
    private int id;
    private String name;
    private int tid;
}
```

```java
@Data
public class Teacher {
    private int id;
    private String name;
    // 一个老师对于多个学生
    private List<Student> students;
}
```

4. MyBatis配置文件

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <properties resource="db.properties"/>
    <settings>
        <setting name="logImpl" value="STDOUT_LOGGING"/>
    </settings>
    <typeAliases>
        <package name="com.demo1.pojo"/>
    </typeAliases>
    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="${driver}"/>
                <property name="url" value="${url}"/>
                <property name="username" value="${username}"/>
                <property name="password" value="${password}"/>
            </dataSource>
        </environment>
    </environments>
    <mappers>
        <mapper class="com.demo1.mapper.TeacherMapper"/>
        <mapper class="com.demo1.mapper.StudentMapper"/>
    </mappers>
</configuration>
```

5. 工具类

```java
public class MybatisUtils {
    public static SqlSessionFactory sqlSessionFactory;
    static {
        try {
            String reources = "mybatis-config.xml";
            InputStream inputStream = Resources.getResourceAsStream(reources);
            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static SqlSession getSqlSession() {
        return sqlSessionFactory.openSession(true);
    }
}
```

6. mapper接口

```java
public interface TeacherMapper {

    // 获取老师
    List<Teacher> getTeacher();
}
```

```java
public interface StudentMapper {

}
```

7. mapper配置文件

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.demo1.mapper.TeacherMapper">
    <select id="getTeacher" resultType="teacher">
        select * from teacher
    </select>
</mapper>
```

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.demo1.mapper.StudentMapper">

</mapper>
```

8. 测试

```java
public class MyTest {
    @Test
    public void myTest1() {
        SqlSession sqlSession = MybatisUtils.getSqlSession();

        TeacherMapper mapper = sqlSession.getMapper(TeacherMapper.class);
        List<Teacher> teachers = mapper.getTeacher();
        for (Teacher teacher : teachers) {
            System.out.println(teacher);
        }

        sqlSession.close();
    }
}
```

9. 目录结构截图

   同上

#### 11-2. 实例：查询指定老师及其下所有学生

方式一、多表查询：

```sql
select s.id sid, s.name sname, t.id tid, t.name
from student s, teacher t
where s.tid = t.id and t.id = #{id};
```

```java
public interface TeacherMapper {
    // 获取指定老师信息及其下所有学生
    Teacher getTeacher(@Param("tid") int id);
}
```

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.demo1.mapper.TeacherMapper">
    <resultMap id="TeacherStudent" type="teacher">
        <result property="id" column="tid"/>
        <result property="name" column="tname"/>
        <collection property="students" ofType="student">
            <result property="id" column="sid"/>
            <result property="name" column="sname"/>
            <result property="tid" column="tid"/>
        </collection>
    </resultMap>
    <select id="getTeacher" resultMap="TeacherStudent">
        select s.id sid, s.name sname, t.id tid, t.name tname from student s, teacher t
        where s.tid = t.id and t.id = #{tid};
    </select>
</mapper>
```

```java
public class MyTest {
    @Test
    public void myTest1() {
        SqlSession sqlSession = MybatisUtils.getSqlSession();

        TeacherMapper mapper = sqlSession.getMapper(TeacherMapper.class);
        Teacher teacher = mapper.getTeacher(1);
        System.out.println(teacher);
        sqlSession.close();
    }
}
```

方式二、按照查询嵌套处理

​	略

### 12. 小结

1. 关联 - assocation 【多对一】
2. 集合 - collection 【一对多】
3. javaType和ofType
   1. javaType用来指定实体类中属性的类型
   2. ofType用来指定映射到List或者集合中的pojo类型，泛型中的约束类型
4. **面试高频**：
   1. Mysql引擎
   2. InnoDB底层原理
   3. 索引
   4. 索引优化

### 13.动态SQL

**什么是动态SQL：动态SQL就是指根据不同的条件生成不同的SQL语句**

* if
* choose(when, otherwise)
* trim(where, set)
* foreach

#### 13-1. 搭建环境

1. 数据库表

```sql
create table blog (
    id varchar(50) not null comment '博客id',
    title varchar(100) not null comment '博客标题',
    author varchar(30) not null comment '博客作者',
    create_time datetime not null comment '创建时间',
    views int(30) not null comment '浏览量'
)ENGINE = InnoDB default charset = utf8
```

2. 对应pojo类

```java
@Data
public class Blog {
    private int id;
    private String title;
    private String author;
    private Date createTime;
    private int views;
}
```

3. 两个工具类

```java
public class MybatisUtil {
    public static SqlSessionFactory sqlSessionFactory;
    static {
        try {
            String reources = "mybatis-config.xml";
            InputStream inputStream = Resources.getResourceAsStream(reources);
            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static SqlSession getSqlSession() {
        return sqlSessionFactory.openSession(true);
    }
}
```

```java
public class IDUtil {
    public static String getID() {
        return UUID.randomUUID().toString().replaceAll("-", "");
    }
}
```

4. 编写mapper及对应xml文件

```java
public interface BlogMapper {
    // 插入数据
    int addBlog(Blog blog);
}
```

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.demo1.dao.BlogMapper">
    <insert id="addBlog" parameterType="blog">
        insert into blog(id, title, author, create_time, views)
        values (#{id}, #{title}, #{author}, #{createTime}, #{views})
    </insert>
</mapper>
```

5. 数据库表与java大小写对应

在Mybatis-config.xml中：

```xml
<settings>
    <setting name="mapUnderscoreToCamelCase" value="true"/>
</settings>
```

6. 测试

```java
public class MyTest {
    @Test
    public void run() {
        SqlSession sqlSession = MybatisUtil.getSqlSession();
        BlogMapper mapper = sqlSession.getMapper(BlogMapper.class);

        Blog blog1 = new Blog();
        blog1.setId(IDUtil.getID());
        blog1.setTitle("MyBatis111");
        blog1.setAuthor("Tinkin");
        blog1.setCreateTime(new Date());
        blog1.setViews(999);
        mapper.addBlog(blog1);


        sqlSession.close();
    }
}
```

#### 13-2. if

1. BlagMapper.java

```java
// 查询博客
/*
        可选查询：当不输入或输入为空时，查询所有
                 当输入为1条时，查这一条
                 ...
     */
List<Blog> queryBlog(Map map);
```

2. BlagMapper.xml

```xml
<select id="queryBlog" parameterType="map" resultType="blog">
    select * from blog where 1=1
    <if test="title != null">
        and title = #{title}
	</if>
    <if test="author != null">
        and author = #{author}
	</if>
</select>
```

3. 测试

```java
@Test
public void run2() {
    SqlSession sqlSession = MybatisUtil.getSqlSession();
    BlogMapper mapper = sqlSession.getMapper(BlogMapper.class);

    HashMap<Object, Object> map = new HashMap<>();
    List<Blog> blogs = mapper.queryBlog(map);
    for (Blog blog : blogs) {
        System.out.println(blog);
    }

    sqlSession.close();
}
```

#### 13-3. trim(where、set)

* 这三个标签是优化SQL语句的
* where标签：只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，where元素也会将它们去除
  * 13-2的if例子可用where标签优化
* set标签：动态地在行首插入 SET 关键字，并会删掉额外的逗号

```xml
<update id="updateAuthorIfNecessary">
  update Author
    <set>
      <if test="username != null">username=#{username},</if>
      <if test="password != null">password=#{password},</if>
    </set>
  where id=#{id}
</update>
```

* trim标签：通过自定义 trim 元素来定制 *where、set* 元素的功能

```xml
<trim prefix="WHERE" prefixOverrides="AND |OR ">
  ...
</trim>

<trim prefix="SET" suffixOverrides=",">
  ...
</trim>
```

#### 13-4. choose(when、otherwise)

* 相当于**switch(case、default)**
* otherwise标签：当所有when标签都不满足时执行

1. BlagMapper.java

```java
// 不选或只能选一项查询
List<Blog> queryBlog2(Map map);
```

2. BlagMapper.xml

```xml
<select id="queryBlog2" parameterType="map" resultType="blog">
    select * from blog
    <where>
    	<choose>
    		<when test="title != null">
    			title = #{title}
			</when>
    		<when test="author != null">
    			author = #{author}
			</when>
    	</choose>
    </where>
</select>
```

3. 测试

```java
@Test
public void run3() {
    SqlSession sqlSession = MybatisUtil.getSqlSession();
    BlogMapper mapper = sqlSession.getMapper(BlogMapper.class);

    HashMap<Object, Object> map = new HashMap<>();
    map.put("title", "Spring111");
    List<Blog> blogs = mapper.queryBlog2(map);
    for (Blog blog : blogs) {
        System.out.println(blog);
    }

    sqlSession.close();
}
```

#### 13-5. SQL片段

有的时候，我们可能会将一些通用代码抽象出来

```xml
<!--  将通用代码抽象出来  -->
<sql id="ifTitleAuthor">
    <if test="title != null">
        title = #{title}
    </if>
    <if test="author != null">
        author = #{author}
    </if>
</sql>
<!--  引用通用代码  -->
<select id="123">
    <include refid="123"></include>
</select>
```

#### 13-6. foreach

* 对集合进行遍历（尤其是在构建 IN 条件语句的时候）
* *foreach* 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符（separator）
* index 是当前迭代的序号，item 的值是本次迭代获取到的元素，当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值
* collection：任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象

1. blog表

![image-20211024224511389](/imgs/image-20211024224511389.png)

2. BlagMapper.java

```java
// 查询第2、3号记录的博客
List<Blog> queryBlog3(Map map)
```

3. BlagMapper.xml

```xml
<select id="queryBlog3" parameterType="map" resultType="blog">
    <!--
    select * from blog where id=2 or id=3
    传入的map是个万能map，里面能存放集合
    -->
    select * from blog
    <where>
    	<foreach collection="list" item="id"
    			open="" close="" separator="or">
    		id = #{id}
		</foreach>
    </where>
</select>
```

4. 测试

```java
@Test
public void run4() {
    SqlSession sqlSession = MybatisUtil.getSqlSession();

    BlogMapper mapper = sqlSession.getMapper(BlogMapper.class);
    HashMap map = new HashMap();
    ArrayList list = new ArrayList();
    list.add(2);
    list.add(3);
    map.put("list", list);
    List<Blog> blogs = mapper.queryBlog3(map);
    for (Blog blog : blogs) {
        System.out.println(blog);
    }

    sqlSession.close();
}
```

#### 13-7. 总结

**动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合就好了**

建议：**先在Mysql中写出完整的SQL语句，再修改成对应的动态SQL**

### 14. 缓存

#### 14-1. 简介

1. 什么是缓存
   * 存在内存中的临时数据
   * 将用户经常查询的数据放在缓存(内存)中，用户查询数据就不用去磁盘上(或关系型数据库文件)查询，而从缓存中读出，从而提高查询效率，解决了高并发系统的性能问题
2. 为什么使用缓存
   * 减少和数据库的交互次数，减少系统开销，提高系统效率
3. 什么样的数据能使用缓存
   * 经常查询并且不经常改变的数据

#### 14-2. MyBatis缓存

* MyBatis包含一个非常强大的查询缓存特性，它可以非常方便的定制和配置缓存，缓存可以极大的提升查询效率
* MyBatis系统中默认定义了两级缓存：**一级缓存**和**二级缓存**
  * 默认情况下，只有一级缓存开启。（sqlsession级别的缓存，也称为本地缓存）
  * 二级缓存需要手动开启和配置，他说基于namespace级别的缓存
  * 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来定义二级缓存

#### 14-3. 一级缓存

* 一级缓存也叫本地缓存
  * 与数据库同一次会话期间查询到的数据会放到本地缓存中
  * 以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库

* 证明存在一级缓存的测试
  * 开启日志
  * 测试代码

```java
@Test
public void run1() {
    SqlSession sqlSession = MybatisUtils.getSqlSession();

    UserMapper mapper = sqlSession.getMapper(UserMapper.class);
    User user1 = mapper.getUserById(1);
    User user2 = mapper.getUserById(1);
    System.out.println(user1 == user2);

    sqlSession.close();
}
```

![20211026224903.png](/imgs/20211026224903.png)

* 缓存失效的情况：

  * 查询不同的东西
  * 增删改操作
  * 查询不同的Mapper.xml
  * 手动清理缓存

  ```java
  sqlSession.clearCache();
  ```

#### 14-4. 二级缓存

* 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存
* 基于namespace级别的缓存，一个名称空间，对应一个二级缓存
* 工作机制
  * 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中
  * 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中
  * 新的会话查询数据，就可以从二级缓存中获取内容
  * 不同的mapper查出的数据会放在自己对应的缓存（map）中
* 步骤：

1. 显示的开启全局缓存（可忽略）

| **设置名**   | **描述**         | **有效值**    | **默认值** |
| ------------ | ---------------- | ------------- | ---------- |
| cacheEnabled | 全局缓存是否开启 | true \| false | true       |

```xml
<settings>
    <setting name="cacheEnabled" value="true"/>
</settings>
```

**`cachedEnable=true`仅仅是使用了`CachingExecutor`，不能代表使用了二级缓存，因为`CachingExecutor`使用了Cache对象缓存数据，只有在Mapper中配置`<cache/>`标签，解析的时候才会有Cache对象，否则还是不会用到二级缓存**

2. 在mapper.xml中开启二级缓存

```xml
<mapper namespace="com.demo1.dao.UserMapper">
    <!--在当前mapper中使用二级缓存-->
    <cache eviction="FIFO"				缓存策略：先进先出（默认）
           flushInterval="60000"		缓存刷新间隔：60s（默认）
           size="512"					最大保留数据数：512条（默认）
           readOnly="true"				是否只读：true（默认）
    	   />
    <select id="getUserById" resultType="user">
        select * from user where id = #{id}
    </select>
</mapper>
```

3. **<cache/>**这个简单语句的效果如下：

* 映射语句文件中的所有 select 语句的结果将会被缓存。
* 映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。
* 缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。
* 缓存不会定时进行刷新（也就是说，没有刷新间隔）。
* 缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。
* 缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改

4. 测试

```java
@Test
public void run2() {
    SqlSession sqlSession1 = MybatisUtils.getSqlSession();
    UserMapper mapper1 = sqlSession1.getMapper(UserMapper.class);
    User user1 = mapper1.getUserById(1);
    System.out.println(user1);
    sqlSession1.close();

    SqlSession sqlSession2 = MybatisUtils.getSqlSession();
    UserMapper mapper2 = sqlSession2.getMapper(UserMapper.class);
    User user2 = mapper2.getUserById(1);
    System.out.println(user2);
    sqlSession2.close();
    
    System.out.println("=============================");
    System.out.println(user1==user2);
    
}
```

* 二级缓存没有开时：

![20211027221131.png](/imgs/20211027221131.png)

* 开了二级缓存：

![20211027221245.png](/imgs/20211027221245.png)

5. 问题：

   1. java.io.NotSerializableException：没有将实体类序列化

   ```java
   import java.io.Serializable;
   @Data
   public class User implements Serializable {
   }
   ```

6. 总结：当二级缓存开启时，一级缓存在关闭时保存的数据会被提交到二级缓存里，随后相同的查询结果会在二级缓存中获取

7. 当使用反序列化对象流的功能时，建议定义JEP-290串行过滤器。
   详情参考：[https://docs.oracle.com/pls/topic/lookup?ctx=javase15&id=GUID-8296D8E8-2B93-4B9A-856E-0A65AF9B8C66](https://docs.oracle.com/pls/topic/lookup?ctx=javase15&id=GUID-8296D8E8-2B93-4B9A-856E-0A65AF9B8C66)

#### 14-5. 缓存原理

先查缓存，查不到再查数据库

#### 14-6. 自定义缓存-ehcache

Ehcache是一种广泛使用的开源java分布式缓存，主要面向通用缓存

不需深究，以后会用**Redis**实现







