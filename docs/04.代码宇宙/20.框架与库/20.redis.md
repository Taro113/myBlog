---
date: 2026-02-16 15:22:03
title: redis
permalink: /tech/e06551
categories:
  - 代码宇宙
  - 框架与库
---

### 1. Nosql概述

#### 1-1. 单机MySQL的年代

* 90年代，一个基本网站的访问量一般不会太大，单个数据库完全足够，这个时候，更多的去使用静态网页HTML，服务器没有太大的压力.
* 思考一下，这种情况下，整个网站的瓶颈是什么？

  1. 数据量如果太大，一个机器内存放不下
  2. 数据库的索引（ B+Tree ），一个机器内存也放不下
  3. 访问量（读写混乱），一个服务器承受不了
* 只要你开始出现以上三种情况之一，那么久必须升级

#### 1-2. Memcached（缓存） + MySQL + 垂直拆分（读写分离）

- 网站有80%的情况都是在读，如果每次查询都会去访问数据库就十分麻烦，所以我们像减轻数据的压力，就可以使用缓存来保证效率
- 缓存的发展过程：优化数据结构和索引-->文件缓存（IO）-->Memcached（当时最热门的技术）

#### 1-3. 分库分表（水平拆分）

数据库的本质：读/写

#### 1-4. 什么是NoSQL

NoSQL = Not Only SQL（不仅仅是SQL）

泛指非关系型数据库

|          | `SQL`   | `NOSQL`  | 举例                 |
| -------- | ------- | -------- | -------------------- |
| 数据结构 | 结构化  | 非结构化 | 表结构、语法、约束等 |
| 数据关联 | 关联的  | 无关联的 | 外键                 |
| 查询方式 | SQL查询 | 命令查询 |                      |
| 事务特性 | ACID    | BASE     |                      |

### 2. Redis入门

#### 1-1. redis是什么

- 官网：[https://redis.io/](https://redis.io/)&emsp;&emsp;&emsp;&emsp;中文官网：[http://www.redis.cn/](http://www.redis.cn/)
- 注意：win系统上的 `Redis` 已经停更很久了，官方也不建议在win上用 `Redis`，所以**最好在 Linux 上用**

* `Redis`（Remote Dictionary Server )，即远程字典服务
* 是一个开源的使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库数据库，并提供多种语言的 API
* `Redis` 是一个 key-value 存储系统，与 memcached 一样，为了保证效率，数据都是缓存在内存中
* `Redis` 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了 master-slave (主从)同步

#### 1-2. redis能做什么

1. 内存存储、持久化，内存是断电即失的，所以持久化很重要
2. 效率高，可以用于高效缓存
3. 简单的消息队列：发布订阅系统
4. 地图信息分析
5. 计数器，计时器
6. ......

#### 1-3. 特性

1. 键值（key-value）型，value 支持多样的数据类型
2. 数据持久化
3. 集群
4. 支持事务
5. 单线程、原子性
6. 速度快，延迟低（基于内存）
7. ...

#### 1-4. 安装

##### 1-4-1. window下安装

1. win 系统下的安装包只能在 Github 上下载安装：[https://github.com/microsoftarchive/redis/tags](https://github.com/microsoftarchive/redis/tags)

![20211104220028.png](/imgs/20211104220028.png)

2. 解压到指定文件夹
3. 双击redis-server.exe启动服务

![20211104220410.png](/imgs/20211104220410.png)

![20211104220604.png](/imgs/20211104220749.png)

4. 使用redis客户端redis-cli.exe来连接redis

![20211104221238.png](/imgs/20211104221238.png)

![20211104221501.png](/imgs/20211104221501.png)

##### 1-4-2. Linux下安装

1. 官网下载：[https://redis.io/](https://redis.io/)

![20211104222634.png](/imgs/20211104222634.png)

![20211104223044.png](/imgs/20211104223044.png)

2. 将压缩包移动到Linux下的/opt目录下并解压（先解压后移动也可以）

```bash
cp -r /mnt/hgfs/IDEApros/redis-6.2.6.tar.gz /opt
cd /opt
tar -zxvf redis-6.2.6.tar.gz
```

![20211104224413.png](/imgs/20211104224413.png)

3. 进入解压后的目录

![20211104224626.png](/imgs/20211104224626.png)

4. 因为`Redis`是由c语言写的，所以其基本环境要安装

```bash
yum install gcc-c++
gcc -v
```

![20211105213812.png](/imgs/20211105213812.png)

```bash
make			# 加载redis所需要的所有c语言文件
make			# 再次make就加快速度了
make install	# 可选操作，用于确认所需文件全部安装了
```

![20211105214416.png](/imgs/20211105214416.png)

5. `Redis`的默认安装路径：/usr/local/bin

![20211105214842.png](/imgs/20211105214842.png)

6. 将原`Redis`配置文件复制一份到当前目录下

![20211105215442.png](/imgs/20211105215442.png)

7. 修改redis.conf

* `Redis`默认不是后台启动，修改配置文件为后台启动

```bash
vi redis.conf
```

![20211105220954.png](/imgs/20211105220954.png)

```bash
bind 192.168.124.50		# 写当前的主机ip
daemonize yes 			# 修改为yes，表示后台启动
requirepass 123456 		# 密码
port 6379				# 监听端口号
dir .					# 工作目录，默认是当前目录
logfile "redis.log"     # log文件，在dir目录下
```

8. 启动`Redis`服务

```bash {4}
cd /usr/local/bin/
ls
# dump.rdb  myconfig  redis-benchmark  redis-check-aof  redis-check-rdb  redis-cli  redis-sentinel  redis-server
redis-server myconfig/redis.conf 
redis-cli -h 192.168.124.50 -p 6379 -a 123456
127.0.0.1:6379>
```

![20211105221947.png](/imgs/20211105221947.png)

若启动客户端用的 `-a` 或 `-u` 命令指定密码时，会警告不安全，则可以用以下方式：

```bash {2}
redis-cli -h 192.168.124.50 -p 6379
127.0.0.1:6379>AUTH 123456
OK
127.0.0.1:6379>
```

9. 关闭`Redis`服务

```bash
shutdown
exit
```

![20211105222529.png](/imgs/20211105222529.png)

10. Window 客户端

> [https://github.com/lework/RedisDesktopManager-Windows/releases](https://github.com/lework/RedisDesktopManager-Windows/releases)

![20221125173903.png](/imgs/20221125173903.png)

#### 1-5. redis-benchmark压力测试工具

![20211106122826.png](/imgs/20211106122826.png)

![20180201145503750.png](/imgs/20180201145503750.png)

**示例**

```bash
# 测试前先开启redis服务：redis-server
redis-benchmark -h localhost -p 6379 -c 100 -n 10000
# 				 指定主机名	   端口号 并发连接数 请求数
```

#### 1-6. 基础知识

- `Redis`默认有16个数据库，默认使用第0个

```bash
127.0.0.1:6379> select 5		# 切换到第5号数据库
OK
127.0.0.1:6379[5]> dbsize		# [5]表示当前所用数据库编号，dbsize表示数据库大小
(integer) 0
```

* `Redis`命令不区分大小写
* `127.0.0.1:6379> keys *` ：查看所有的key

* `127.0.0.1:6379> flushdb`：清空当前数据库
* `127.0.0.1:6379> flushall`：清空所有数据库

- `Redis`是单线程的
  - `Redis`是基于内存操作，CPU不是`Redis`性能瓶颈，`Redis`的性能瓶颈是根据机器的内存和网络带宽，既然可以使用单线程来实现，就使用单线程了

- `Redis`为什么是单线程还这么快？
  - 误区1：高性能服务器一定是多线程的
  - 误区2：多线程（CPU上下文切换会耗时）一定比单线程效率高        速度：CPU>内存>硬盘
  - 核心：`Redis`是将所有东西放在内存中的，对于内存系统来说，没有上下文切换效率就是最高的

### 3. 数据类型

> ![20211106222832.png](/imgs/20211106222832.png)
全文翻译：
`Redis` 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作**数据库**、缓存和**消息中间件**。 
它支持多种类型的数据结构，如字符串（strings），散列（hashes），列表（lists），集合（sets），有序集合（sorted sets）与
范围查询，bitmaps ，hyperloglogs 和地理空间（geospatial）索引半径查询。
`Redis` 内置了 复制（replication），LUA脚本（Lua scripting），LRU驱动事件（LRU eviction），事务（transactions）和
不同级别的磁盘持久化（persistence），并通过`Redis`哨兵（Sentinel）和自动分区（Cluster)提供高可用性（high availability）

---

**五大常用数据类型：**

#### 3-1. String

- 字符串是一种最基本的`Redis`值类型。`Redis`字符串是二进制安全的，这意味着一个`Redis`字符串能包含任意类型的数据，例如： 一张JPEG格式的图片或者一个序列化的Ruby对象
- 一个字符串类型的值最多能存储**512MB**的内容
- 对于整数，`Redis` 内部采用整数（Integer）形式来存储对应的整数值，所以对该类字符串值实际上是用整数保存，也就不存在存储整数的字符串表示所带来的额外消耗

1. 命令

| 格式          | 说明                                                                                 |
| ------------- | ------------------------------------------------------------------------------------ |
| set key value | 将键`key`设定为指定的“字符串”值，具有覆盖效果，能够重置 `expire` 时间使 `TTL` 返回-1 |
| get key       | 返回`key`的`value`，如果key不存在，返回空值`nil`。如果`value`不是string，就返回错误  |
|               |                                                                                      |
|               |                                                                                      |
|               |                                                                                      |
|               |                                                                                      |
|               |                                                                                      |
|               |                                                                                      |
|               |                                                                                      |
|               |                                                                                      |
|               |                                                                                      |




```bash
set key value
linsert
```

2. 实例

```bash
#########################################################################################
# 基本操作
127.0.0.1:6379> set name Tinkin				# 设置值，若key存在，则直接覆盖，包括类型
OK
127.0.0.1:6379> get name					# 获取值
"Tinkin"
127.0.0.1:6379> keys *						# 获取所有值，支持正则表达式
1) "name"
127.0.0.1:6379> exists name					# 判断是否存在
(integer) 1
127.0.0.1:6379> append name s				# 追加到末尾
(integer) 7
127.0.0.1:6379> get name
"Tinkins"
127.0.0.1:6379> append name "'"				# 追加的另一种写法
(integer) 8
127.0.0.1:6379> get name
"Tinkins'"
127.0.0.1:6379> strlen name					# 获取长度
(integer) 8
127.0.0.1:6379> append age 18				# 如果当前key不存在，则为set
(integer) 2
127.0.0.1:6379> get age
"18"
#########################################################################################
# 加减
127.0.0.1:6379> set view 0
OK
127.0.0.1:6379> incr view					# 原子增1，若key不存在，则会先set为0，再incr
(integer) 1
127.0.0.1:6379> incr view
(integer) 2
127.0.0.1:6379> decr view					# 原子减1，若key不存在同incr
(integer) 1
127.0.0.1:6379> get view
"1"
127.0.0.1:6379> incrby view 10				# 增加指定的整数，若key不存在，则先set为0，再incrby
(integer) 11
127.0.0.1:6379> decrby view 4				# 减去指定的整数，若key不存在，同incrby
(integer) 7
#########################################################################################
# 获取子串
127.0.0.1:6379> set strs "this is a strings"
OK
127.0.0.1:6379> getrange strs 0 3			# 返回对应的子串，最后一个字符为-1
"this"
# 替换字串
127.0.0.1:6379> set strs "hello, world"
OK
127.0.0.1:6379> get strs
"hello, world"
127.0.0.1:6379> setrange strs 7 "Tinkin"	# 从指定处开始，覆盖新串的长度
(integer) 12
127.0.0.1:6379> get strs
"hello, Tinkin"
#########################################################################################
# setnx(set key if not exist)
# setex(set expire) 设置过期时间
127.0.0.1:6379> setex str 10 "123456"		# expire key time ，单位s
OK
127.0.0.1:6379> ttl str						# 获取key的有效时间
(integer) 7									# 如果key不存在或者已过期，返回 -2
127.0.0.1:6379> ttl str						# 如果key存在且没有设置过期时间（永久有效），返回 -1
(integer) 3	
127.0.0.1:6379> keys *
(empty array)
127.0.0.1:6379> setnx str "123"				# if not exist
(integer) 1
127.0.0.1:6379> get str
"123"
127.0.0.1:6379> setnx str "456"				# key存在所以setnx无效果
(integer) 0
127.0.0.1:6379> get str
"123"
#########################################################################################
# 批量设置key
127.0.0.1:6379> mset k1 v1 k2 v2 k3 v3		# 批量设置值
OK
127.0.0.1:6379> mget k1 k2 k3				# 批量获取值
1) "v1"
2) "v2"
3) "v3"
127.0.0.1:6379> msetnx k1 val1 k4 val4		# 原子操作，if not exist
(integer) 0
127.0.0.1:6379> mget k1 k4
1) "v1"
2) (nil)
# 设置对象的两种方式
# 1. 设置一个user1对象，值为json类型
set user:1:{name:Tinkin,age:22}
# 2. user:{id}:{field}，这样在Redis中是完全ok的
mset user:1:name Tinkin user:1:age 22
#########################################################################################
# getset，如表面意思一样。在Redis里，像这样的组合命令还有跟多，后面就不列举了
127.0.0.1:6379> getset name Tin
(nil)
127.0.0.1:6379> get name
"Tin"
127.0.0.1:6379> getset name kin
"Tin"
127.0.0.1:6379> get name
"kin"
#########################################################################################
# del	type	expire
127.0.0.1:6379> set str strings
OK
127.0.0.1:6379> type str
string
127.0.0.1:6379> del str
(integer) 1
127.0.0.1:6379> get str
(nil)
127.0.0.1:6379> set str strs
OK
127.0.0.1:6379> expire str 10				# 设置有效存活时间
(integer) 1
127.0.0.1:6379> ttl str
(integer) 4
127.0.0.1:6379> get str
"strs"
127.0.0.1:6379> get str
(nil)
#########################################################################################
```

* String 的应用场景（字符串和数字）：
  * 计数器
  * 统计多单位的数量
  * 对象缓存存储
  * ......

#### 3-2. List

- 一般来说，List 有两种实现方式：数组和 Linked List，它们在属性方面大不相同。而 Redis List 是基于 Linked Lists 实现
- Redis Lists 用 linked list 实现的原因是：
  - 对于数据库系统来说，至关重要的特性是：能非常快的在很大的列表上添加元素。
  - 另一个重要因素是，正如你将要看到的：Redis lists 能在常数时间取得常数长度
- Redis List 是简单的字符串列表，按照插入顺序排序
- 对一个空 key 执行操作 list 命令时，将会创建一个新表，类似的，如果要删除某个 list，只需清空该表即可
- Redis List 可以当栈、队列、阻塞队列使用

1. 命令

```bash

```

2. 实例

```bash
#########################################################################################
# 基础操作
127.0.0.1:6379> lpush ll 3					# 插入到列表头部
(integer) 1
127.0.0.1:6379> rpush ll 4					# 插入到列表尾部
(integer) 2
127.0.0.1:6379> lrange ll 0 -1				# 从list中取出一定范围的元素
1) "3"
2) "4"
127.0.0.1:6379> lpush ll 1 2				# push多个值是按先后顺序分开push的
(integer) 4
127.0.0.1:6379> rpush ll 5 6 7
(integer) 7
127.0.0.1:6379> lrange ll 0 -1
1) "2"
2) "1"
3) "3"
4) "4"
5) "5"
6) "6"
7) "7"
127.0.0.1:6379> lset ll 0 1					# 修改值
(integer) 4
127.0.0.1:6379> lset ll 1 2
(integer) 7
127.0.0.1:6379> lrange ll 0 -1
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"
6) "6"
7) "7"
127.0.0.1:6379> lindex ll 1					# 通过下标获取列表元素
(integer) "2"
127.0.0.1:6379> llen ll						# 获取列表长度
(integer) 7
#########################################################################################
# 删除元素
127.0.0.1:6379> lpop ll						# 弹出列表头部的元素
"2"
127.0.0.1:6379> lpop ll
"1"
127.0.0.1:6379> rpop ll						# 弹出列表尾部的元素
"7"
127.0.0.1:6379> rpush ll 4
(integer) 5
127.0.0.1:6379> lrange ll 0 -1
1) "3"
2) "4"
3) "5"
4) "6"
5) "4"
# lrem key count value：从存于 key 的列表里移除前 count 次出现的值为 value 的元素
127.0.0.1:6379> lrem ll 1 4	
(integer) 1
127.0.0.1:6379> lrange ll 0 -1
1) "3"
2) "5"
3) "6"
4) "4"
#########################################################################################
# 截取指定长度的元素
127.0.0.1:6379> rpush ll 1 2 3 4 5
(integer) 5
127.0.0.1:6379> lrange ll 0 -1
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"
127.0.0.1:6379> ltrim ll 0 2				# 从左边开始截取元素
OK
127.0.0.1:6379> lrange ll 0 -1
1) "1"
2) "2"
3) "3"
#########################################################################################
# 关于阻塞的BRPOP和BLPOP命令
# 127.0.0.1:6379> BLPOP lll 1 100
# 此时没有lll这个列表，所以会等100秒，直到弹出这个值，等待期间一直是阻塞的
#########################################################################################

#########################################################################################

#########################################################################################
```



#### 3-3. Set

- Redis Set 是 String 的无序排列

1. 命令

```bash

```

2. 实例

```bash
#########################################################################################
# 基础操作
127.0.0.1:6379> sadd ss 1 2 3				# 添加一个或多个元素到set里
(integer) 3
127.0.0.1:6379> smembers ss					# 获取set里的所有元素
1) "1"
2) "2"
3) "3"
127.0.0.1:6379> scard ss					# 获取元素数量
(integer) 3
127.0.0.1:6379> spop ss						# 随机弹出一个元素
"3"
127.0.0.1:6379> smembers ss
1) "1"
2) "2"
#########################################################################################
# 交集   并集	差集
127.0.0.1:6379> sadd set1 1 2 3
(integer) 3
127.0.0.1:6379> sadd set2 3 4 5
(integer) 3
127.0.0.1:6379> sinter set1 set2			# 获取交集
1) "3"
127.0.0.1:6379> sunion set1 set2			# 获取并集
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"
127.0.0.1:6379> sunionstore sets set1 set2	# 存储并集结果到sets中
(integer) 5
127.0.0.1:6379> smembers sets
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"
127.0.0.1:6379> sdiff set1 set2				# 获取差集
1) "1"
2) "2"
#########################################################################################

#########################################################################################
```



#### 3-4. Hash

- `Redis`操作Hash的命令都是以h/H开头的
- Redis Hash是字符串字段和字符串值之间的映射，所以它们是能完美表示对象的数据类型

1. 命令

```bash
hlen
hexists
hkeys
hvals
```

2. 实例

```bash
#########################################################################################
# 基础操作
# 创建一个为user:1的map,其中的一个key-val对为name,zhansan
127.0.0.1:6379> hset user:1 name zhangsan
(integer) 1
# 为名为user:1的map设置多个key-val对
127.0.0.1:6379> hmset user:1 age 18 birthyear 2003 
OK
127.0.0.1:6379> hget user:1 age				# 通过key获取val
"18"
127.0.0.1:6379> hgetall user:1				# 获取所有
1) "name"
2) "zhangsan"
3) "age"
4) "18"
5) "birthyear"
6) "2003"
127.0.0.1:6379> hdel user:1 birthyear		# 删除一个或多个值
(integer) 1
127.0.0.1:6379> hmget user:1 name age 		# 多次获取
1) "zhangsan"
2) "18"
127.0.0.1:6379> 
#########################################################################################
# hincrby
127.0.0.1:6379> hgetall user:1
1) "name"
2) "zhangsan"
3) "age"
4) "18"
5) "birthyear"
6) "2003"
127.0.0.1:6379> hincrby user:1 age 4			# 增加指定数值
(integer) 22
127.0.0.1:6379> hget user:1 age
"22"
127.0.0.1:6379> 
#########################################################################################

#########################################################################################
```



#### 3-5. Zset(Sorted Set)

- `Redis`操作Zset的命令都是以z/Z开头的
- Sorted set是一种类似于集合和哈希混合的数据类型，它和`Redis` Set类似，是不包含相同字符串的合集。它们的差别是，每个有序集合的成员都关联着一个评分，这个评分用于把有序集合中的成员按最低分到最高分排列
- Sorted set中的每个元素都与一个浮点值相关联，称为*分数*（这就是为什么类型类似于散列，因为每个元素都映射到一个值），默认是按照分数**从小到大排序**
- **排序实现说明**：Sorted set 是通过双端口数据结构实现的，包含一个skip list 和一个hash table，所以每次我们添加一个元素`Redis`都会执行一个O(log(N))的操作。这很好，但是当我们要求排序元素时，`Redis` 根本不需要做任何工作，它已经全部排序了

1. 命令

```bash
zadd 分值对
```

2. 实例

```bash
#########################################################################################
# 基础操作
127.0.0.1:6379> clear
127.0.0.1:6379> zadd hackers 1940 "Alan Kay"	# 添加一个或多个值
(integer) 1
127.0.0.1:6379> zadd hackers 1957 "Sophie Wilson" 1953 "Richard Stallman"
(integer) 2
127.0.0.1:6379> zrange hackers 0 -1				# 显示所有元素
1) "Alan Kay"
2) "Richard Stallman"
3) "Sophie Wilson"
127.0.0.1:6379> zrevrange hackers 0 -1			# 倒序显示所有元素
1) "Sophie Wilson"
2) "Richard Stallman"
3) "Alan Kay"
127.0.0.1:6379> zrangebyscore hackers -inf +inf	# 显示范围限制内的所有元素
1) "Alan Kay"
2) "Richard Stallman"
3) "Sophie Wilson"
127.0.0.1:6379> zcard hackers					# 获取集合长度
(integer) 2
#########################################################################################
# 删除
127.0.0.1:6379> zrem hackers "Richard Stallman"	# 移除元素
(integer) 1
127.0.0.1:6379> zrange hackers 0 -1
1) "Alan Kay"
2) "Sophie Wilson"

#########################################################################################

#########################################################################################
```

- 应用场景：
  - 优先级
  - 排行榜

---

> **三大特殊数据类型**

#### 3-6.  geospatial（地理位置）

- 命令都以geo开头

- 因为geo底层的实现原理是Zset，所以我们也可以用Zset命令来操作geo

- 将指定的地理空间位置（纬度、经度、名称）添加到指定的`key`中。这些数据将会存储到**sorted set**

- 有效经纬度

  - 有效的经度从-180度到180度
  - 有效的纬度从-85.05112878度到85.05112878度
  - 当指定位置超过上述指定范围时，会返回一个错误

  ```bash
  127.0.0.1:6379> geoadd china 177.2 177.2 beijing
  (error) ERR invalid longitude,latitude pair 177.200000,177.200000
  ```


1. 命令

```bash
geoadd		经度、纬度、名称
GEOADD
GEODIST
GEOPOS
GEORADIUS
GEORADIUSBYMEMBER
GEOHASH作为了解即可
```

2. 实例

```bash
#########################################################################################
127.0.0.1:6379> geoadd china 116.40 39.90 beijing						#添加一个或多个坐标
(integer) 1
127.0.0.1:6379> geoadd china 121.47 31.23 shanghai
(integer) 1
127.0.0.1:6379> geoadd china 106.50 20.53 chongqing
(integer) 1
127.0.0.1:6379> geoadd china 114.05 29.53 shenzhen
(integer) 1
127.0.0.1:6379> geoadd china 120.16 30.24 hangzhou 108.96 34.26 xian
(integer) 2
127.0.0.1:6379> geopos china xian										#显示经纬度
1) 1) "108.96000176668167114"
   2) "34.25999964418929977"
127.0.0.1:6379> geopos china beijing shanghai
1) 1) "116.39999896287918091"
   2) "39.90000009167092543"
2) 1) "121.47000163793563843"
   2) "31.22999903975783553"
127.0.0.1:6379> geodist china beijing shanghai							#显示直线距离
"1067378.7564"
127.0.0.1:6379> geodist china beijing shanghai km
"1067.3788"
127.0.0.1:6379> georadius china 110 30 1000 km 							#查找半径范围内元素
1) "xian"
2) "shenzhen"
3) "hangzhou"
127.0.0.1:6379> georadiusbymember china beijing 500 km withdist			#
1) 1) "beijing"
   2) "0.0000"
127.0.0.1:6379> georadiusbymember china beijing 1000 km withdist
1) 1) "beijing"
   2) "0.0000"
2) 1) "xian"
   2) "910.0565"
#########################################################################################
```

- 应用场景：
  - 定位
  - 附近的场所
  - 两个地理位置之间的距离

#### 3-7.  Hyperloglog

- 命令都以PF开头
- Hyperloglog是基于集合基数概念的一种数据类型。需要记住过去已经看过的元素，以避免对它们进行多次计数
- 优点：不再需要使用与元素数量成正比的内存量，而是可以使用恒定量的内存！最坏情况下为 12k 字节

1. 命令

```bash

```

2. 实例

```bash
#########################################################################################
127.0.0.1:6379> pfadd h1 a b c d				# 添加数据
(integer) 1
127.0.0.1:6379> pfadd h2 c d e f g
(integer) 1
127.0.0.1:6379> pfmerge hh h1 h2				# 并集
OK
127.0.0.1:6379> pfcount hh						# 长度
(integer) 7
127.0.0.1:6379> 
#########################################################################################
```

#### 3-8.  Bitmaps(位图)

- 命令都以bit开头或结尾
- 位图不是实际的数据类型，而是在 String 类型上定义的一组面向位的操作
- 通过操作二进制来进行记录，只有0和1**两种状态**
  - 365天 = 365bit = 46B

1. 命令

```bash

```

2. 实例

```bash
#########################################################################################
127.0.0.1:6379> setbit maps 1 0					# 设置
(integer) 0
127.0.0.1:6379> setbit maps 0 0
(integer) 0
127.0.0.1:6379> getbit maps 1					# 获取
(integer) 0
127.0.0.1:6379> setbit maps 2 1
(integer) 0
127.0.0.1:6379> getbit maps 2
(integer) 1
127.0.0.1:6379> bitcount maps					# 统计字符串被设置为1的bit数
(integer) 1
127.0.0.1:6379> bitcount maps 0 -1
(integer) 1
#########################################################################################
```

---

### 4. 事务

- `Redis`事务本质：一组命令的集合。一个事务中的所有命令都会被序列化，在事务执行的过程中，会按照顺序执行。即一次性、顺序性、排他性（执行过程中不允许被干扰）。

  -------------------  队列  set  set  get  set  get  队列  ------------------------

- **`Redis`单条命令能保证原子性，但`Redis`中的事务则不保证原子性**

- `Redis`事务没有隔离级别的概念，即在事务中，所有命令先加入到队列中，发出执行命令(Exec)时才执行

- 事务执行完后，会被销毁，但所做的操作已经做完了

#### 4-1. Redis事务：

- 开启事务（multi）
- 命令入队（. . . . . .）
- 执行事务（exec）

```bash
127.0.0.1:6379> multi
OK
127.0.0.1:6379(TX)> set k1 v1
QUEUED
127.0.0.1:6379(TX)> set k2 v2
QUEUED
127.0.0.1:6379(TX)> get k2
QUEUED
127.0.0.1:6379(TX)> set k3 v3
QUEUED
127.0.0.1:6379(TX)> exec
1) OK
2) OK
3) "v2"
4) OK
```

#### 4-2. 放弃事务

```bash
127.0.0.1:6379> multi
OK
127.0.0.1:6379(TX)> set k1 11
QUEUED
127.0.0.1:6379(TX)> discard
OK
127.0.0.1:6379> get k1
"v1"
```

#### 4-3. 编译型异常

- （语法、命令错误），事务中所有命令都不会被执行

```bash
127.0.0.1:6379> multi
OK
127.0.0.1:6379(TX)> set k1 v1
QUEUED
127.0.0.1:6379(TX)> getset k2
(error) ERR wrong number of arguments for 'getset' command
127.0.0.1:6379(TX)> set k3 v3
QUEUED
127.0.0.1:6379(TX)> exec
(error) EXECABORT Transaction discarded because of previous errors.
```

#### 4-4. 运行时异常

- （逻辑错误，使用错误），错误命令抛出异常，其他命令正常执行

```bash
127.0.0.1:6379> set k "val"
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379(TX)> incr k
QUEUED
127.0.0.1:6379(TX)> set kk "vv"
QUEUED
127.0.0.1:6379(TX)> get kk
QUEUED
127.0.0.1:6379(TX)> exec
1) (error) ERR value is not an integer or out of range
2) OK
3) "vv"
```

#### 4-5. 监控

- 悲观锁
  - 很悲观：认为什么时候都会出问题，所以无论做什么都会加锁

- 乐观锁
  - 很乐观：认为什么时候都不会出问题，所以不会上锁

#### 4-6 Redis监视(watch)测试

- 当正常执行成功时

```bash
127.0.0.1:6379> set money 100					# 余额
OK
127.0.0.1:6379> set out 0						# 支出
OK
127.0.0.1:6379> watch money						# 监控money变量
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379(TX)> incrby out 10
QUEUED
127.0.0.1:6379(TX)> decrby money 10
QUEUED
127.0.0.1:6379(TX)> exec
1) (integer) 10
2) (integer) 90
```

> 当事务成功执行后，监控(watch)会自动取消

- 一个失败场景：

  1. 第一个线程

  ```bash
  127.0.0.1:6379> watch money
  OK
  127.0.0.1:6379> multi
  OK
  127.0.0.1:6379(TX)> incrby out 20
  QUEUED
  127.0.0.1:6379(TX)> decrby money 20
  QUEUED
  ```

  2. 此时第二个线程

  ```bash
  127.0.0.1:6379> set money 1000
  OK
  ```

  3. 第一个线程继续执行

  ```bash
  127.0.0.1:6379> watch money
  OK
  127.0.0.1:6379> multi
  OK
  127.0.0.1:6379(TX)> incrby out 20
  QUEUED
  127.0.0.1:6379(TX)> decrby money 20
  QUEUED
  127.0.0.1:6379(TX)> 
  127.0.0.1:6379(TX)> 
  127.0.0.1:6379(TX)> exec
  (nil)												# 返回一个null，说明此事务执行失败
  127.0.0.1:6379> unwatch								# 取消监控
  OK
  ```

### 5. Jedis

- Jedis是`Redis`官方推荐的java开发连接工具，使用Java操作`Redis`中间件
- 后面我们会用Springboot整合`Redis`来代替Jedis

#### 5-1. 使用方法

1. 导入对应依赖

```xml
<!-- Jedis -->
<dependency>
    <groupId>redis.clients</groupId>
    <artifactId>jedis</artifactId>
    <version>3.6.3</version>
</dependency>
<!-- fastjson -->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>fastjson</artifactId>
    <version>1.2.76</version>
</dependency>
```

2. 开启要接入的`Redis`

![20211116230040.png](/imgs/20211116230040.png)

3. 编码测试

   1. 连接数据库

   2. 操作命令

   3. 断开连接

   ```java
   public static void main(String[] args) {
       // 1. new Jedis对象即可
       Jedis jedis = new Jedis("localhost", 6379);
   
       System.out.println(jedis.ping());
   
       // 关闭连接
       jedis.close();
   }
   ```

### 6.SpringBoot整合

- SpringBoot操作数据：spring-data、jpa、jdbc、mongodb、redis

- 说明：在SpringBoot2.0以后，Jedis就被替换成了lettuce
  - Jedis：
  - lettuce：

#### 6-1. 整合测试

1. 导入依赖
2. 配置连接
3. 测试





### 9.redis集群

在`/redisClu`目录下创建`redis_7001`~`redis_7006`这七个目录，在这七个目录中创建`bin`目录，并将安装好的也就是`/usr/local/bin/*`目录下所有文件拷贝到这七个`bin`目录下，并修改相关配置：

`redis.conf`中主要修改下面几个：

```bash
bind 192.168.3.44
port 7001
cluster-enabled yes
masterauth redis123456 
requirepass redis123456 
pidfile /var/run/redis_7001.pid
logfile /redisClu/redis_7001/node.log
dbfilename "dump.rdb"
daemonize yes
```

在`/redisClu`目录下添加两个集中启动与关闭文件：

```bash
# start-all.sh

cd /redisClu/redis_7001/bin
./redis-server redis.conf&
cd ..
cd /redisClu/redis_7002/bin
./redis-server redis.conf&
cd ..
cd /redisClu/redis_7003/bin
./redis-server redis.conf&
cd ..
cd /redisClu/redis_7004/bin
./redis-server redis.conf&
cd ..
cd /redisClu/redis_7005/bin
./redis-server redis.conf&
cd ..
cd /redisClu/redis_7006/bin
./redis-server redis.conf&
cd ..
```

```bash
# shutdown-all.sh

cd /redisClu/redis_7001/bin
./redis-cli -h 192.168.3.44 -p 7001 -a redis123456 shutdown
cd ..
cd /redisClu/redis_7002/bin
./redis-cli -h 192.168.3.44 -p 7002 -a redis123456 shutdown
cd ..
cd /redisClu/redis_7003/bin
./redis-cli -h 192.168.3.44 -p 7003 -a redis123456 shutdown
cd ..
cd /redisClu/redis_7004/bin
./redis-cli -h 192.168.3.44 -p 7004 -a redis123456 shutdown
cd ..
cd /redisClu/redis_7005/bin
./redis-cli -h 192.168.3.44 -p 7005 -a redis123456 shutdown
cd ..
cd /redisClu/redis_7006/bin
./redis-cli -h 192.168.3.44 -p 7006 -a redis123456 shutdown
cd ..
```

启动每个`redis`后，在7001目录下执行：

````bash
./redis-cli -h 192.168.0.213 -p 7001 -a redis123456 --cluster create 192.168.0.213:7001 192.168.0.213:7002 192.168.0.213:7003 192.168.0.213:7004 192.168.0.213:7005 192.168.0.213:7006 --cluster-replicas 1
````

执行完成后，就会创建集群信息，然后再查看集群信息：

```bash
./redis-cli -c -h 192.168.0.213 -p 7001 -a redis123456 cluster nodes
```

出现：

```bash
d296ea8ba2c5b0c2010f1a3465cfad4fb76a7252 192.168.0.213:7002@17002 slave 453482b9f0086dcb83cf29c10c3562f84132fa75 0 1626800038545 8 connected
3576fb47fefb10dc5ec73a7c639d8c0dc26ea49b 192.168.0.213:7003@17003 master - 0 1626800037541 3 connected 10923-16383
6f122e1390b2b6ec69464b678fb992f5f0ee144a 192.168.0.213:7004@17004 slave 3576fb47fefb10dc5ec73a7c639d8c0dc26ea49b 0 1626800036000 4 connected
24ec2402a285b3a9cc67b3369398cb2fe5c22fd7 192.168.0.213:7005@17005 master - 0 1626800037000 7 connected 0-5460
453482b9f0086dcb83cf29c10c3562f84132fa75 192.168.0.213:7006@17006 master - 0 1626800035000 8 connected 5461-10922
3b9bb03c876c76a111b741d08a760a8b317f2be5 192.168.0.213:7001@17001 myself,slave 24ec2402a285b3a9cc67b3369398cb2fe5c22fd7 0 1626800038000 1 connected
```

表示成功

登录集群：

```bash
redis-cli -c -h 10.12.4.45 -p 7001 -a redis123456
# -c 以集群方式登陆。cluster
# -a 密码。authority
```

修复集群：若发现集群有问题，可尝试用下面命令修复

```bash
#集群修复
./redis-cli -c -h 192.168.0.213 -p 7001 -a redis123456 --cluster fix 192.168.0.213:7001
```

