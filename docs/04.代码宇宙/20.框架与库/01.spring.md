---
date: 2026-02-18 18:29:13
title: spring
permalink: /tech/ccf767
categories:
  - 代码宇宙
  - 框架与库
---

### 1. 简介

- 2002年，首次推出了Spring框架的雏形：interface21框架
- Spring框架于2004年3月24日发布了1.0正式版

- **Rod Johnson**：Spring Framework创始人，悉尼大学博士，专业是音乐学
- Spring理念：使现有的技术更加容易使用，本身是个大杂烩，整合了现有的技术框架

- 官网：[https://spring.io/projects/spring-framework#overview](https://spring.io/projects/spring-framework#overview)
- 官方下载地址：[https://repo.spring.io/ui/native/release/org/springframework/spring](https://repo.spring.io/ui/native/release/org/springframework/spring)

- Github：[https://github.com/spring-projects/spring-framework](https://github.com/spring-projects/spring-framework)

```xml
<!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>5.3.9</version>
</dependency>
```

#### 1-1 优点

- 开源免费的框架（容器）
- 轻量级、非入侵式

- 两个特性：**控制反转（IOC）、面向切面编程（AOP）**

- 支持事务的处理，对框架整合的支持

  **总结：Spring就是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架！**

#### 1-2 组成

![20211029224330.png](/imgs\20211029224330.png)

#### 1-3 拓展

* 在Spring官网这句话：Spring:the source for modern java(Spring是java现代化的开发)，说白就是基于Spring的开发

![20211029224552.png](/imgs\20211029224552.png)

- Spring boot

- - 一个快速开发的脚手架
  -  基于SpringBoot可以快速开发单个服务

- - 约定大于配置

- Spring Cloud

- - 基于SpringBoot实现的

现在大多数公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提是要完全掌握Spring与SpringMVC

**弊端：发展了太久之后，违背了原来的理念！配置十分繁琐**

### 2. IOC理论推导

#### 	2-1 初次推导

* 业务调用：dao接口--daoimpl实现类---service业务接口--serviceimpl业务实现类

* 修改一次的成本代价十分昂贵

* 此时，我们使用一个set动态注入，已经发生了革命性的变化

```java
public class UserServiceImpl implements UserService{
    
    private UserDao userdao;
    
     // 利用setUser去实现值动态注入
    public void setUserDao(UserDao userdao) {
        this.userdao = userdao;
    }
    
    @Override
    public void getUser() {
        userdao.getUser();
    }
}
```

- 之前，程序员主动的创建对象，控制权在程序员手上
- 使用了set注入后，程序不在具有主动性，而是变成了被动的接收对象

* 这种思想，从本质上解决了问题，我们程序员不用再去管理对象的创建了，系统的耦合性大大降低，可以更加专注的在业务的实现上，这就是IOC的原型。

![img](/imgs\20211029225037.png)

#### 2-2 IOC本质

* **控制反转IoC（Inversion of Control），是一种设计思想，DI（依赖注入）只是实现IoC的其中一种方式**，也有人认为DI只是IoC的另一种说法，在没有IoC的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为控制反转就是：获得依赖对象的方式反转了

![img](/imgs\20211029225120.png)

* Spring容器在初始化是先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从容器中取出需要的对象

* 采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的

* **控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）**

#### 2-3 UserServiceImpl

- set注入：

![img](/imgs\20211029225524.png)

```xml
<bean id="userDaoImpl" class="iocTest.UserDaoImpl"/>
<bean id="userServiceImpl" class="iocTest.UserServiceImpl">
<!--name：属性名
    value：属性值
    ref：spring中已配置管理的beanId
-->
    <property name="userDao" ref="userDaoImpl"/>
</bean>
```

```java
public class MyMain {
    public static void main(String[] args) {
        // ApplicationContext是spring的上下文对象
        ApplicationContext context = new ClassPathXmlApplicationContext("bean.xml");
        UserServiceImpl service = (UserServiceImpl) context.getBean("userServiceImpl");
        service.getUser();
    }
}
```

- 对象由Spring创建，对象的属性也由Spring设置，这个过程就是控制反转
- 控制：传统应用程序的对象由程序本身创建，使用Spring后，对象由Spring创建

- 反转：程序本身不创建对象，而变成被动的接受对象
- 依赖注入：利用set方法来进行注入

- **所谓的IoC，一句话：对象由Spring创建、管理、分配**

### 3. IOC创建对象的方式

#### 3-1 无参构造

* 默认为无参构造创建对象

#### 3-2 有参构造

1. 参数名赋值（重点）

```xml
<bean id="user" class="pojo.User">
    <constructor-arg name="name" value="124"/>
</bean>
```

2. 下标赋值

    ```xml
        <constructor-arg index="0" value="124"/>
    ```

3. 类型赋值（不推荐）

    ```xml
        <constructor-arg type="java.lang.String" value="124"/>
    ```

#### 3-3 总结

* 只要配置文件被加载，容器中管理的对象就已经初始化了

### 4.Spring配置

#### 4-1 别名

* 起了别名后，原名和别名都可使用，还代表源对象

```xml
<alias name="user" alias="userNew"/>
```

#### 4-2 bean的配置

- id：bean的唯一标识符，也就相当于对象名
- class：bean的全类名

- name：也是别名，但更高级，可以同时取多个别名

```xml
<bean id="user" class="pojo.User" name="u1 u2, u3; u4" scope="">
    <constructor-arg name="name" value="124"/>
</bean>
```

#### 4-3 import

- 一般用于团队开发，将多个配置文件导入合并为一个

* 假如一个项目由多个人开发，用import将所有人的配置文件导入到applicationcontext.xml配置文件中，那么就会将所有配置文件合并为这个applicationcontext.xml文件，使用的时候只需加载这个applicationcontext.xml就行了。

```xml
<import resource="bean1.xml"/>
<import resource="bean2.xml"/>
<import resource="bean3.xml"/>
```

### 5. DI依赖注入

#### 5-1 构造器注入

- 就是3-1和3-2的构造器注入

#### 5-2 Set方式注入（重点）

- 依赖注入：其实就是Set注入

  - 依赖：bean对象的创建依赖于容器
  - 注入：bean对象中的所有属性由容器来注入

【模拟注入环境】

1. Student.java

```java
public class Student {
    private String name;
    private Address address;        // Address是个普通的类
    private String[] books;
    private List<String> hobbys;
    private Map<String, String> card;
    private Set<String> games;
    private String wife;
    private Properties info;
}
```

2. bean.xml

```xml
<bean id="address" class="di.pojo.Address"/>
<bean id="student" class="di.pojo.Student">
    <property name="name" value="张三"/>          <!-- 普通值注入 -->
    <property name="address" ref="address"/>      <!-- bean注入 -->
    <property name="books">                       <!-- 数组引入 -->
        <array>
            <value>三国演义</value>
            <value>西游记</value>
            <value>红楼梦</value>
            <value>水浒传</value>
        </array>
    </property>
    <property name="hobbys">                      <!-- List注入 -->
        <list>
            <value>听歌</value>
            <value>码代码</value>
            <value>看电影</value>
        </list>
    </property>
    <property name="card">                       <!-- Map注入 -->
        <map>
            <entry key="学号" value="2018001"/>
            <entry key="身份证号" value="411527xxxxxxxxxxxx"/>
        </map>
    </property>
    <property name="games">                     <!-- Set注入 -->
        <set>
            <value>Dota2</value>
            <value>PVZ</value>
        </set>
    </property>
    <property name="wife">                      <!-- null -->
        <null/>
    </property>
    <property name="info">                      <!-- Properties -->
        <props>
            <prop key="姓名">张三</prop>
            <prop key="性别">男</prop>
            <prop key="出生日期">2000.03.15</prop>
        </props>
    </property>
```

3. MyTest.java

```java
public static void main(String[] args) {
    ApplicationContext context = new ClassPathXmlApplicationContext("di\\bean.xml");
    Student student = (Student) context.getBean("student");
    System.out.println(student);
}

/**
 * Student{
 * name='张三',
 * address=Address{}, 
 * books=[三国演义, 西游记, 红楼梦, 水浒传],
 * hobbys=[听歌, 码代码, 看电影], 
 * card={学号=2018001, 身份证号=411527xxxxxxxxxxxx},
 * games=[Dota2, PVZ], 
 * wife='null',
 * info={性别=男, 出生日期=2000.03.15, 姓名=张三}}
 */
```

#### 5-3 拓展方式注入

1. 带有 p 命名空间的 XML 快捷方式

```xml
<!-- 添加约束 -->
xmlns:p="http://www.springframework.org/schema/p"
```

```xml
<!-- p：就是property首字母缩写 -->
<bean id="user" class="pojo.User" p:name="李四"/>
```

2. 带有 c 命名空间的 XML 快捷方式

```xml
<!-- 添加约束 -->
xmlns:c="http://www.springframework.org/schema/c"
```

```xml
<!-- c：就是constructor首字母缩写 -->
<bean id="user" class="pojo.User" c:name="李四"/>
```

- **其实p命名空间对应Set注入，c命名空间对应构造器注入**

#### 5-4 bean的作用域

1. 单例模式（默认是单例）：只在加载时创建一个对象，以后每次引用都是这一个对象

```xml
<bean id="address" class="di.pojo.Address" scope="singleton"/>
```

2. 原型模式：每次引用都创建一个新对象

```xml
<bean id="address" class="di.pojo.Address" scope="prototype"/>
```

3. 其余的request、session、application、websocket都只能在web开发中用到

### 6. bean的自动装配

- 自动装配是Spring满足bean依赖的的一种方式
- Spring会在上下文中自动寻找，并自动给bean装配属性

* 在Spring中有三种自动装配的方式：

	1. 在xml中显示配置
	2. 在java中显示配置
	3. 隐式的自动装配bean（重点）

#### 6-1 环境模拟

一个人有两只宠物：

```xml
<bean id="dog" class="demo1.Dog"/>
<bean id="cat" class="demo1.Cat"/>

<bean id="people" class="demo1.People">
    <property name="name" value="张三"/>
    <property name="dog" ref="dog"/>
    <property name="cat" ref="cat"/>
</bean>
```

#### 6-2 byName自动装配

autowire="byName"会自动在容器上下文中查找，和自己对象的set方法后面的值对应的beanId

```xml
<bean id="dog" class="demo1.Dog"/>
<bean id="cat" class="demo1.Cat"/>

<bean id="people" class="demo1.People" autowire="byName">
    <property name="name" value="张三"/>
<!--    <property name="dog" ref="dog"/>-->
<!--    <property name="cat" ref="cat"/>-->
</bean>
```

#### 6-3 byType自动装配

autowire="byType"会自动在容器上下文中查找，和自己对象属性类型相同的bean

```xml
<bean id="dog" class="demo1.Dog"/>
<bean id="cat" class="demo1.Cat"/>

<bean id="people" class="demo1.People" autowire="byType">
   <property name="name" value="张三"/>
<!--   <property name="dog" ref="dog"/>-->
<!--   <property name="cat" ref="cat"/>-->
</bean>
```

#### 6-4 小结

- byName的时候需要保证所有bean的id唯一，并且这个必须要和自动注入的属性的set方法的值一致
- byType的时候需要保证所有bean的class唯一，并且这个必要要和自动注入的属性的类型一致

#### 6-5 使用注解实现自动装配

* jdk从1.5开始支持注解，spring从2.5开始支持注解

* The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML.

* 要使用注解须知：

	1. 导入约束

	```xml
	xmlns:context="http://www.springframework.org/schema/context"
	http://www.springframework.org/schema/context 
	https://www.springframework.org/schema/context/spring-context.xsd
	```
	
	2. 配置注解的支持
	
	 ```xml
	 <?xml version="1.0" encoding="UTF-8"?>
	 <beans xmlns="http://www.springframework.org/schema/beans"
	     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	     xmlns:context="http://www.springframework.org/schema/context"
	     xsi:schemaLocation="http://www.springframework.org/schema/beans 
	         https://www.springframework.org/schema/beans/spring-beans.xsd
	         http://www.springframework.org/schema/context 
	         https://www.springframework.org/schema/context/spring-context.xsd">
	   
	     <context:annotation-config/>
	   
	 </beans>
	 ```

##### @Autowired

- 直接在属性上使用即可，也可以在set方式上使用

- 其原理是利用反射IoC容器中已存在的属性实现装配，且符合byType

- 注解源码：

  - 这个注解有一个boolean类型的属性required，其默认值为true

  ```java
  public @interface Autowired {
      boolean required() default true;
  }
  ```

- 科普：

  - @Nullable：字段标记了这个注解，说明这个字段可以为null
  
  ```java
  public People(@Nullable String name) {
      this.name = name;
  }
  ```
  
  - @Autowired(required = false)：显式说明required=false，则该对象可以为null，否则不能为null
  
  ```java
  @Autowired(required = false)
  private Dog dog;
  ```
  
  - @Qualifier(value = "cat1")：限定了哪个bean应该被自动注入
  
  ```java
  @Qualifier(value = "cat1")
  private Cat cat;
  ```
  
  - @Resource：java自带的注解，默认是autowire="byName"方式实现，找不到则通过autowire="byType"方式实现
  
  ```java
  @Resource
  private Dog dog;
  ```

### 7. 使用注解开发

- 使用注解开发必须要加入context约束和支持

- 在Spring4之后，要使用注解开发，则必须要导入aop依赖

```xml
<!--注解驱动-->
<context:annotation-config/>
<!--指定要扫描的包，使该包下的所有注解生效-->
<context:component-scan base-package="demo2"/>
```

#### 7-1 bean

- @Component：放在类上，说明此类被Spring管理了，相当于xml中的<bean/>

#### 7-2 属性如何注入

- @Value("")：放在属性上，给属性赋值

#### 7-3 衍生的注解

- @Component有几个衍生的注解，在web开发的mvc架构中会用到

  - dao            --    【@Repository】
  - service       --    【@Service】

  - controller  --    【@Controller】

- 这四个注解，其功能是一样的，都是将某个类注册到Spring中，装配Bean

#### 7-4 自动装配置

- @Autowired
- @Qualifier

#### 7-5 作用域

- @Scope("")：里面写singleton或prototype

#### 7-6 小结

- xml与注解：

  - xml更加万能，适用于任何场合，维护简单方便
  - 注解不是自己的类使用不了，维护相对复杂

  - 和解之法：xml用来管理bean，注解只用来管理属性的注入

### 8. 使用java方式配置Spring

也就是用java类完全替代xml配置文件

```java
@Configuration
@ComponentScan(value = "demo2")
@Import(value = applictionContext2.class)
public class MyConfig {
    @Bean       // 没扫描也能找到
    public User getUser() {         // 方法名就是beanId
        return new User();
    }
}
```

```java
public class MyTest2 {
    @Test
    public void run1() {
        // 若是使用了配置类的方式，使用AnnotationConfigApplicationContext获取配置类，
        // 参数直接传入类名.class即可，无需关注类路径
        ApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class);
        User user = context.getBean("getUser", User.class);
        System.out.println(user.name);
    }
}
```

### 9. 代理模式

* 为什么要学代理模式？因为这个就是SpringAOP的底层

#### 9-1 代理模式的分类

- 静态代理
- 动态代理

#### 9-2 静态代理

1. 角色分析

- 抽象角色：一般会使用接口或是抽象类来解决

- 真实角色：被代理的角色

- 代理角色：代理上面的真实角色，代理后，一般还会做一些附属操作
- 客户：访问代理对象的人

2. 好处

- 可以使真实角色的操作更加纯粹，不用去关注一些公共业务
- 公共业务就交给代理角色，实现了业务的分工

- 公共业务发生拓展的时候，方便集中管理

​    缺点：

- 每一个真实角色都会产生一个代理角色，代码量翻倍，效率变低

3. 实例

- 租房

#### 9-3 动态代理

- 动态代理和静态代理角色一样
- 动态代理的代理类是动态生成的，不是我们直接写好的
- 动态代理分为两大类：基于接口的动态代理、基于类的动态代理

  - 基于接口---JDK的动态代理
  - 基于类的---cglib

  - java字节码实现---JAVAssit
- 需要了解两个类：Proxy：代理、InvocationHandler：调用处理程序

```java
// 租房
public interface Rent {
    public void rent();
}
```
```java
// 房东
public class Host implements Rent {
    public void rent() {
        System.out.println("房东要出租房子");
    }
}
```
```java
// 我们会用这个类自动生成代理类
public class ProxyInvocationHandler implements InvocationHandler {

    // 被代理的接口
    private Rent rent;

    public void setRent(Rent rent) {
        this.rent = rent;
    }

    // 生成代理类
    public Object getProxy() {
        return Proxy.newProxyInstance(this.getClass().getClassLoader(),
                rent.getClass().getInterfaces(), this );
    }

    // 处理代理实例，并返回结果
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 动态代理的本质就是使用反射实现
        Object result = method.invoke(rent,args);
        return result;
    }
}
```
```java
public class Client {
    public static void main(String[] args) {
        // 真实角色
        Host host = new Host();

        // 代理角色：现在没有
        ProxyInvocationHandler pih = new ProxyInvocationHandler();
        // 用过调用程序处理角色，来处理我们要调用的接口对象
        pih.setRent(host);
        Rent proxy = (Rent) pih.getProxy();
        proxy.rent();
    }
}
```

- 动态代理的好处

  - 静态代理的好处全都有：

    - 可以使真实角色的操作更加纯粹，不用去关注一些公共业务
  - 公共业务就交给代理角色，实现了业务的分工

    - 公共业务发生拓展的时候，方便集中管理

  - 一个动态代理类代理的是一个接口，一般就是对应的一类业务
  - 一个动态代理类可以代理多个类，只要是实现了同一个接口即可

### 10. AOP

#### 10-1 什么是AOP

AOP (Aspect Oriented Programming)意为：面向切面编程,通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一一个重要内容,是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。

![img](/imgs\20211029232326.png)

#### 10-2 AOP在Spring的作用

提供声明式事务；允许用户自定义切面

- 横切关注点:跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志，安全，缓存，事务等等.....                                                             比如做个日志
- 切面（ASPECT）：横切关注点被模块化的特殊对象。即，它是一个类。                                     就是Log类
- 通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。                                       就是Log中的方法
- 目标（Target）：被通知对象。即，要切入的方法。														   						    一个接口或方法
- 代理（Proxy）：向目标对象应用通知之后创建的对象。																			   生成的代理类
- 切入点（PointCut）：切面通知执行的“地点"的定义。																				   就是PointCut
- 连接点（JointPoint）：与切入点匹配的执行点。																							   同上

![20211029232451.png](/imgs\20211029232451.png)

在SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的

| 通知类型     | 连接点实现接口       | 实现接口                                    |
| ------------ | -------------------- | ------------------------------------------- |
| 前置通知     | 方法前               | org.springframe.aop.MethodBeforeAdvice      |
| 后置通知     | 方法后               | org.springframe.aop.AfterReturningAdvice    |
| 环绕通知     | 方法前后             | org.aopalliance.intercept.MethodInterceptor |
| 异常抛出通知 | 方法抛出异常         | org.springframe.aop.throwsAdvice            |
| 引介通知     | 类中增加新的方法属性 | org.springframe.aop.IntroductionInterceptor |

即Aop在不改变原有代码的情况下，去增加新的功能

#### 10-3 使用Spring实现AOP

【重点】使用AOP织入，需要导入一个依赖

```xml
<!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver -->
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
    <version>1.9.6</version>
    <scope>runtime</scope>
</dependency>
```

1. 使用Spring的API接口【主要是Spring接口实现】

![img](/imgs\20211029232555.png)

```java
public interface UserService {
    public void add();
    public void del();
    public void updata();
    public void select();
}
```
```java
public class UserServiceImpl implements UserService{
    public void add() {
        System.out.println("UserServiceIMpl.add()增加......");
    }

    public void del() {
        System.out.println("UserServiceIMpl.del()删除......");
    }

    public void updata() {
        System.out.println("UserServiceIMpl.updata()修改......");
    }

    public void select() {
        System.out.println("UserServiceIMpl.select()查找......");
    }
}
```
```java
public class Log implements MethodBeforeAdvice {
    /**
     * 在传入目标对象的目标方法前，执行该方法
     * @param method 目标方法
     * @param objects 方法参数
     * @param o 目标对象
     */
    public void before(Method method, Object[] objects, Object o) throws Throwable {
        System.out.println(o.getClass().getName()+"."+method.getName()+"()......");
    }

}
```
```java
public class AfterLog implements AfterReturningAdvice {
    /**
     * 该方法在传入的方法返回后执行
     * @param returnValue 返回值
     * @param method 方法
     * @param args 方法参数
     * @param o1 对象
     * @throws Throwable
     */
    public void afterReturning(Object returnValue, Method method, Object[] args, Object o1) throws Throwable {
        System.out.println(o1.getClass().getName()+"."+method.getName()+"()......, return="+returnValue);
    }
}
```
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd">

    <bean id="userService" class="demo4.service.UserServiceImpl"/>
    <bean id="log" class="demo4.log.Log"/>
    <bean id="afterLog" class="demo4.log.AfterLog"/>
    <!--配置AOP-->
    <aop:config>
        <!--切入点：execution(执行的位置)-->
        <aop:pointcut id="pointcut" expression="execution(* demo4.service.UserServiceImpl.*(..))"/>
        <!--执行环绕增加-->
        <aop:advisor advice-ref="log" pointcut-ref="pointcut"/>
        <aop:advisor advice-ref="afterLog" pointcut-ref="pointcut"/>
    </aop:config>

</beans>
```
```java
public class MyTest1 {

    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("demo4\\applicationContext.xml");
        // 动态代理代理的是接口
        UserService userService = context.getBean("userService", UserService.class);
        userService.add();
    }
}
```
```txt
E:\software\jdk-8u181-windows-x64\bin\java.exe "-javaagent:E:\software\IDEA\IntelliJ IDEA 
demo4.service.UserServiceImpl.add()......
UserServiceIMpl.add()增加......
demo4.service.UserServiceImpl.add()......, return=null

Process finished with exit code 0
```

2. 自定义类来使用AOP【主要是切面定义】

```java
public class DiyPointCut {
    public void before() {
        System.out.println("======before======");
    }
    public void after() {
        System.out.println("======after======");
    }
}
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd">

    <bean id="userService" class="demo4.service.UserServiceImpl"/>
    <bean id="diy" class="demo4.diy.DiyPointCut"/>
    <aop:config>
        <aop:aspect ref="diy">
            <!--切入点-->
            <aop:pointcut id="point" expression="execution(* demo4.service.UserServiceImpl.*(..))"/>
            <!--通知-->
            <aop:before method="before" pointcut-ref="point"/>
            <aop:after method="after" pointcut-ref="point"/>
        </aop:aspect>
    </aop:config>

</beans>
```


3. 使用注解实现

```java
@Aspect
public class AnnotationPointCut {
    @Before("execution(* demo4.service.UserServiceImpl.*(..))")
    public void before() {
        System.out.println("======方法执行前======");
    }
    @After("execution(* demo4.service.UserServiceImpl.*(..))")
    public void after() {
        System.out.println("======方法执行后======");
    }
    @Around("execution(* demo4.service.UserServiceImpl.*(..))")
    public void around(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println("===环绕前===");
        // 执行方法
        joinPoint.proceed();
        System.out.println("===环绕后===");
    }
}
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd">

    <bean id="userService" class="demo4.service.UserServiceImpl"/>
    <bean id="annotationPointCut" class="demo4.diy.AnnotationPointCut"/>
    <!--开启注解支持-->
    <aop:aspectj-autoproxy/>

</beans>
```

```html
E:\software\jdk-8u181-windows-x64\bin\java.exe "-javaagent:E:\software\IDEA\IntelliJ IDEA 
===环绕前===
======方法执行前======
UserServiceIMpl.add()增加......
======方法执行后======
===环绕后===

Process finished with exit code 0
```

### 11. myBatis



### 12. 声明式事务

#### 12-1 回顾事务

- 把一组业务当成一个业务来做；要么都成功，要么都失败
- 事务在项目开发中，十分重要，涉及到数据的一致性问题，不能马虎

- 确保完成性和一致性
- 事务的ACID原则：

  - 原子性：要么都完成，要么都不完成
  - 一致性：

  - 隔离性：每个事物都是独立的，但多个业务可能会操作同个资源，那么每个事物都防止数据损坏
  - 持久性：事务一旦提交，无论系统发生什么事情，结果都不被影响，被持久化的写到存储器中

#### 12-2 